{"meta":{"title":"蓝胖纸","subtitle":"哆啦A梦","description":"我的大雄呢","author":"lanpangzhi","url":"http://blog.langpz.com"},"pages":[{"title":"","date":"2018-06-21T08:05:23.861Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"404.html","permalink":"http://blog.langpz.com/404.html","excerpt":"","text":"L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/koharu.model.json\"},\"display\":{\"position\":\"right\",\"width\":100,\"height\":200},\"mobile\":{\"show\":false},\"react\":{\"opacityDefault\":1,\"opacityOnHover\":0.2}});"},{"title":"","date":"2018-06-21T08:05:23.865Z","updated":"2018-06-21T08:05:23.865Z","comments":false,"path":"tags/index.html","permalink":"http://blog.langpz.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"解决移动端click事件300毫秒延迟和点透问题","slug":"解决移动端click事件300毫秒延迟和点透问题","date":"2018-06-21T10:53:59.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"解决移动端click事件300毫秒延迟和点透问题.html","link":"","permalink":"http://blog.langpz.com/解决移动端click事件300毫秒延迟和点透问题.html","excerpt":"解决移动端click事件300毫秒延迟和点透问题click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，移动端浏览器就等待 300 毫秒，以判断用户是否再次点击了屏幕。","text":"解决移动端click事件300毫秒延迟和点透问题click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，移动端浏览器就等待 300 毫秒，以判断用户是否再次点击了屏幕。 fastclick老项目建议用fastclick解决，这样改动起来成本比较小。https://github.com/ftlabs/fastclick引用fastclick库就可以解决300毫秒延迟和点透问题12345678910// 原生js调用if (&apos;addEventListener&apos; in document) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; FastClick.attach(document.body); &#125;, false);&#125;// jquery调用$(function() &#123; FastClick.attach(document.body);&#125;); 使用移动端事件代替click例如touchstart 等事件，建议使用Hammer手势库https://github.com/hammerjs/hammer.js 12345var a = document.querySelector(&apos;.a&apos;);var hammer = new Hammer(a);hammer.on(&apos;tap&apos;, function(e) &#123; console.log(&quot;2222!&quot;);&#125;); 参考https://github.com/ftlabs/fastclickhttps://github.com/hammerjs/hammer.js","categories":[],"tags":[{"name":"点透","slug":"点透","permalink":"http://blog.langpz.com/tags/点透/"},{"name":"移动端","slug":"移动端","permalink":"http://blog.langpz.com/tags/移动端/"}]},{"title":"vue2.0的生命周期","slug":"vue的生命周期","date":"2018-06-14T09:48:11.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"vue的生命周期.html","link":"","permalink":"http://blog.langpz.com/vue的生命周期.html","excerpt":"vue2.0的生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。","text":"vue2.0的生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 生命周期钩子函数代码演示地址beforeCreate 在实例初始化之后调用，数据和事件都没绑定。 所以在beforeCreate访问不到任何东西。created 在实例创建完成后被立即调用。数据和事件已经绑定，但是模板没有渲染，$el属性不可见 。 在created数据和事件都可以访问了，就能打印出数据。beforeMount 模板渲染前调用 beforeMount的时候可以访问到 $el 但是并没有渲染到页面上（virtual DOM）数据也还是这样的格式，所以不能操作DOM。mounted 模板渲染到页面上调用 mounted 的时候就可以操作dom，可以把dom操作放到这个生命周期。beforeUpdate 数据更新时调用，发生在虚拟 DOM 打补丁之前。在控制台执行 vm.lanpangzhi = 3 beforeUpdate 这个钩子函数可以访问更新前的dom元素。这里的dom元素并没有更新掉。updated 数据更新完触发。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。beforeDestroy 实例销毁之前调用。在控制台执行 vm.$destroy() 当这个钩子被调用时实例还可以用。destroyed 实例销毁后调用。 调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 个人总结created （实例创建完） 这个钩子函数可以用来请求数据发ajax。mounted （模板渲染完） 这个钩子函数可以用来操作dom一些方法，如果你用了jQuery需要把代码放到这个钩子函数里面。beforeUpdate （数据更新完） 这个钩子函数通常最好使用计算属性或 watcher 取而代之。destroyed （实例销毁之前调用） 这个钩子函数触发的时候可以用来清理定时器变量。还有几个钩子函数没有说到，建议自行去官网查看。 生命周期图示 beforeCreate在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用。该钩子在服务器端渲染期间不被调用。 mountedel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted该钩子在服务器端渲染期间不被调用。 beforeUpdate数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 updated由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated该钩子在服务器端渲染期间不被调用。 beforeDestroy实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。 destroyedVue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 参考https://cn.vuejs.org/v2/api/#beforeCreate","categories":[],"tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"http://blog.langpz.com/tags/vue2-0/"},{"name":"生命周期","slug":"生命周期","permalink":"http://blog.langpz.com/tags/生命周期/"}]},{"title":"webpack4.0入门指南（二）转换es7语法解析静态资源","slug":"webpack4-0入门指南（二）转换es7语法解析静态资源","date":"2018-06-13T13:30:47.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"webpack4-0入门指南（二）转换es7语法解析静态资源.html","link":"","permalink":"http://blog.langpz.com/webpack4-0入门指南（二）转换es7语法解析静态资源.html","excerpt":"webpack4.0入门指南（二）转换es7语法解析静态资源之前写了怎么转换es6的语法，如果在项目中用了es7的语法和样式，图片，字体该如何配置，下面就写一下配置。","text":"webpack4.0入门指南（二）转换es7语法解析静态资源之前写了怎么转换es6的语法，如果在项目中用了es7的语法和样式，图片，字体该如何配置，下面就写一下配置。 转换es7语法把之前demo3文件夹一份命名为demo4。修改demo4/src/index.js文件1234let obj = &#123;name: &apos;lanpangzhi&apos;&#125;;let obj2 = &#123;blog: &apos;http://blog.langpz.com&apos;&#125;;let newObj = &#123;...obj, ...obj2&#125;; // es7语法console.log(newObj); 安装babel插件，在项目根目录执行命令1npm install babel-preset-stage-0 -D // ES7不同阶段语法提案的转码规则（共有4个阶段） stage-0 包含 stage-1 stage-2 stage-3 阶段 还包含 babel-plugin-transform-do-expressionsbabel-plugin-transform-function-bind 两个插件的功能，阶段标准 修改demo4/.babelrc文件123&#123; &quot;presets&quot;: [&quot;env&quot;,&quot;stage-0&quot;]&#125; 在demo4路径下执行 webpack，就看到打包成功了打开demo4/index.js文件控制台就输出。{name: “lanpangzhi”, blog: “http://blog.langpz.com&quot;} 解析CSS为了从 JavaScript 模块中 import 一个 CSS 文件，你需要配置如下loader。安装babel插件，在项目根目录执行命令。1npm install --save-dev style-loader css-loader 修改demo4/webpack.config.js文件 在rules数组里添加一个规则。1234567&#123; test: /\\.css$/, // 匹配所有.css结尾的文件 use: [ // use要从右往左写，先转成样式，再打包到style标签 &apos;style-loader&apos;, &apos;css-loader&apos; ]&#125; 创建css文件1cd src &amp;&amp; touch index.css 修改demo4/src/index.css文件123body &#123; background: red;&#125; 引入css文件修改demo4/src/index.js文件12// 最上面添加一行import &apos;./index.css&apos;; 在demo4路径下执行 webpack，就看到打包成功。打开demo4/index.html就有红色的背景色了。 解析sass为了从 JavaScript 模块中 import 一个 scss 文件，你需要配置如下loader。安装babel插件，在项目根目录执行命令。1npm install sass-loader node-sass webpack --save-dev 修改demo4/webpack.config.js文件，在rules数组里添加一个规则。12345678&#123; test: /\\.scss$/, // 匹配所有.scss结尾的文件 use: [ &apos;style-loader&apos;, // 将 JS 字符串生成为 style 节点 &apos;css-loader&apos;, // 将 CSS 转化成 CommonJS 模块 &apos;sass-loader&apos; // 将 Sass 编译成 CSS ]&#125; 创建scss文件1cd src &amp;&amp; touch index.scss 修改demo4/src/index.scss文件1234$body-color: yellow;body &#123; background: $body-color;&#125; 修改demo4/src/index.js文件12// 最上面一行替换如下代码import &apos;./index.scss&apos;; 在demo4路径下执行 webpack，就看到sass编译成功。打开demo4/index.html就有绿色的背景色了。!()[http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180613163909.png]如果你想解析其他预处理css语言安装对应loader，添加规则就可以编译了。如less less-loader。 解析图片假想，现在我们正在下载 CSS，但是我们的背景和图标这些图片，要如何处理呢？使用 file-loader，我们可以轻松地将这些内容混合到 CSS 中。安装babel插件，在项目根目录执行命令。1npm install --save-dev file-loader 随意再网上下载一个png图片放到demo4/src/目录下，命名为1.png 修改demo4/src/index.scss文件123body &#123; background: url(./1.png);&#125; 修改demo4/webpack.config.js文件，在rules数组里添加一个规则。1234567891011&#123; test: /\\.(png|svg|jpg|gif)$/, // 匹配所有.png和.svg和.jpg和.gif结尾的文件 use: [ &#123; loader: &apos;file-loader&apos;, options: &#123; publicPath: &apos;dist/&apos; // 设置public 发布目录。 &#125; &#125; ]&#125; 在demo4路径下执行 webpack，就看到图片编译成功。打开demo4/index.html就有背景图。 加载字体像字体这样的其他资源如何处理呢？file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。这就是说，我们可以将它们用于任何类型的文件，包括字体。让我们更新 webpack.config.js 来处理字体文件。修改demo4/webpack.config.js文件，在rules数组里添加一个规则。123456&#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ &apos;file-loader&apos; ]&#125; 如果样式文件里面引入了字体就会被打包，这里就不演示了。 demo仓库地址https://github.com/lanpangzhi/webpack-demo","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.langpz.com/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://blog.langpz.com/tags/打包工具/"}]},{"title":"yarn使用介绍","slug":"yarn使用介绍","date":"2018-06-12T14:19:09.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"yarn使用介绍.html","link":"","permalink":"http://blog.langpz.com/yarn使用介绍.html","excerpt":"yarn使用介绍Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。Yarn要比npm要快一些，而且还更稳定，而且和npm使用相同的软件包流程也一样，下面只介绍一些常用的方法。尽快从npm上手yarn。","text":"yarn使用介绍Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。Yarn要比npm要快一些，而且还更稳定，而且和npm使用相同的软件包流程也一样，下面只介绍一些常用的方法。尽快从npm上手yarn。 安装1npm install -g yarn 初始化新项目1yarn init 等同于 npm init， -y参数也是一样。 添加依赖包安装全局包需要先执行yarn global bin 然后把获取到的路径添加到环境变量path里面，感觉很麻烦也可以用 npm i -g 安装1yarn global add create-react-app // 全局安装等同于 npm i -g create-react-app 安装包信息将加入到dependencies（生产阶段的依赖）12yarn add forever // 等同于 npm install forever -S yarn add forever@2.0.0 // 安装2.0.0版本 将依赖项添加到不同依赖项类别分别添加到 devDependencies、peerDependencies 和 optionalDependencies123yarn add express --dev // 等同于 npm install forever -D yarn add express --peeryarn add express --optional peerDependencies “同伴依赖”，一种特殊的依赖，在发布包的时候需要。有这种依赖意味着安装包的用户也需要和包同样的依赖。 这对于像 react 这样也被人安装的、需要单一 react-dom 副本的包很有用。optionalDependencies 这是可选依赖，意味着依赖是……可选的。这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的。 升级包12yarn upgrade express // 等同于 npm update expressyarn global upgrade express // 等同于 npm update npm update express -g 删除包12yarn remove express // 等同于 npm uninstall expressyarn global remove express // 等同于 npm uninstall -g express 安装项目的全部依赖1yarn or yarn install // 等同于 npm install 查看包安装信息12yarn list // 等同于 npm listyarn global list // npm list -g 上面就是比较常用的方法了，可以快速从npm切换到yarn上，更多方法可以去官网查看。 参考https://yarnpkg.com/zh-Hans/","categories":[],"tags":[{"name":"yarn","slug":"yarn","permalink":"http://blog.langpz.com/tags/yarn/"}]},{"title":"webpack4.0入门指南（一）安装和转换es6语法","slug":"webpack入门指南","date":"2018-06-08T10:35:24.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"webpack入门指南.html","link":"","permalink":"http://blog.langpz.com/webpack入门指南.html","excerpt":"webpack4.0入门指南（一）安装和转换es6语法webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack v4.0.0 开始，可以不用引入一个配置文件。","text":"webpack4.0入门指南（一）安装和转换es6语法webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack v4.0.0 开始，可以不用引入一个配置文件。 安装12npm install -g webpacknpm install -g webpack-cli 需要先全局安装你才可以使用webpack命令，然后再安装到你的项目依赖。如果你使用 webpack 4+ 版本，你还需要安装 CLI。 新建项目123mkdir webpack-demo &amp;&amp; cd webpack-demo //创建并进入webpack-demo文件夹npm init -y // 初始化项目package.json文件npm install -D webpack webpack-cli // 本地安装 webpack和webpack-cli 使用默认配置去构建1234mkdir demo1 &amp;&amp; cd demo1touch index.htmlmkdir src &amp;&amp; cd srctouch index.js index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- webpack会把src/index.js文件打包到dist目录mian.js --&gt; &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; src/index.js12let a = 1;alert(a); 执行 webpack 命令。就可以看到文件被打包到dist文件夹了。打开index.html文件就会弹出1。webpack4.0可以不用写配置文件，然而大多数项目会需要很复杂的设置，需要你自己去配置。 使用配置文件123456cd .. // 返回到webpack-demo文件夹touch webpack.config.js // 创建配置文件touch index.htmlmkdir demo2 &amp;&amp; cd demo2 // 创建demo2文件夹mkdir src &amp;&amp; cd srctouch index.js webpack.config.js123456789const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/index.js&apos;, // 入口文件 output: &#123; // 出口文件 filename: &apos;bundle.js&apos;, // 打包后命名为bundle.js path: path.resolve(__dirname, &apos;dist&apos;) // 输出的路径 &#125;&#125;; 在项目的demo2目录执行webpack。如下图就代表打包成功。打开demo2下面的index.html 就可以弹出我的博客地址。 使用babel转换es6语法 =&gt; es5安装babel在webpack-demo路径下执行命令1npm install --save-dev babel-loader babel-core babel-preset-env 把demo2复制一份命名为demo3，在src目录下再新建a.js。src/a.js1export default lanpangzhi = &quot;blog.langpz.com&quot;; src/index.js12import lanpz from &quot;./a.js&quot;;console.log(lanpz); webpack.config.js1234567891011121314151617181920const path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./src/index.js&apos;, // 入口文件 output: &#123; // 出口文件 filename: &apos;bundle.js&apos;, // 打包后命名为bundle.js path: path.resolve(__dirname, &apos;dist&apos;) // 输出的路径 &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, // 匹配所有.js结尾的文件 exclude: /node_modules/, // 忽略node_modules文件夹 use: &#123; loader: &apos;babel-loader&apos; // 使用babel-loader转义 &#125; &#125; ] &#125;&#125;; 新建 .babelrc 文件1touch .babelrc .babelrc123&#123; &quot;presets&quot;: [&quot;env&quot;]&#125; 执行webpack就可以看见打包成功了。 babel-polyfill由于 Babel 只转换语法(如箭头函数)， 你可以使用 babel-polyfill 支持新的全局变量，例如 Promise 、新的原生方法如 String.padStart (left-pad) 等。在webpack-demo路径下执行命令1npm install --save babel-polyfill // 安装babel-polyfill 在 webpack.config.js 中，将 babel-polyfill 加到你的 entry 数组中。123module.exports = &#123; entry: [&quot;babel-polyfill&quot;, &quot;./src/index.js&quot;]&#125;; 执行webpack命令，如下图就成功了。 demo仓库地址https://github.com/lanpangzhi/webpack-demo 参考https://www.babeljs.cn/https://webpack.docschina.org/","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.langpz.com/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"http://blog.langpz.com/tags/打包工具/"}]},{"title":"部署小说api服务到腾讯云","slug":"部署小说api服务到腾讯云","date":"2018-05-29T11:00:08.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"部署小说api服务到腾讯云.html","link":"","permalink":"http://blog.langpz.com/部署小说api服务到腾讯云.html","excerpt":"部署小说api服务到腾讯云小说api1.0版本写完了，接下来就开始部署到服务器上，用到了nginx、pm2、nvm、git、OpenSSL。","text":"部署小说api服务到腾讯云小说api1.0版本写完了，接下来就开始部署到服务器上，用到了nginx、pm2、nvm、git、OpenSSL。服务器配置: CentOS 7.4 64位 1 核 2 GB 1 Mbpsnode版本: 8.9.0nvm版本: 0.33.11npm版本： 5.5.1nginx版本：1.12.2git版本: 2.9.5 第一步添加pm2配置文件在小说api项目的根目录创建一个pm2.json的文件。12345678910111213141516171819202122232425&#123; &quot;name&quot;: &quot;novel-api&quot;, // 服务名 &quot;script&quot;: &quot;./bin/www&quot;, // 启动脚本 &quot;cwd&quot;: &quot;./&quot;, // 当前工作路径 &quot;watch&quot;: [ // 监控变化的目录，一旦变化，自动重启 &quot;bin&quot;, &quot;routers&quot; ], &quot;ignore_watch&quot;: [ // 从监控目录中排除 &quot;node_modules&quot;, &quot;logs&quot;, &quot;public&quot;, &quot;log&quot; ], &quot;watch_options&quot;: &#123; &quot;followSymlinks&quot;: false &#125;, &quot;max_memory_restart&quot;: &quot;1G&quot;, // 根据内存限制重新启动应用程序。 &quot;error_file&quot;: &quot;./logs/novel-apierr.log&quot;, // 错误日志路径 &quot;out_file&quot;: &quot;./logs/novel-api-out.log&quot;, // 普通日志路径 &quot;env&quot;: &#123; &quot;DEBUG&quot;: &quot;novel-api&quot;, // 环境变量参数，debug名字为novel-api，8080端口监听 &quot;PORT&quot;: &quot;8080&quot; &#125;&#125; package.json文件添加npm run deploy部署命令。1&quot;deploy&quot;: &quot;pm2 start pm2.json&quot; pm2 常用命令。pm2 save 保存当前进程列表。pm2 resurrect 启动之前保存的进程列表。pm2 restart app.js|app_name 重启进程pm2 start app.js 启动进程pm2 list 查看进程列表pm2 stop app_name |app_id 停止指定的应用。 all 停止所有应用 第二步购买服务器和域名购买服务器https://buy.cloud.tencent.com/cvm?tab=lite，我买的是CentOS 7.4 64位 1 核 2 GB 1 Mbps的服务器。如果只是尝试部署流程，可以选择按时计费。购买域名https://dnspod.cloud.tencent.com/?from=qcloudProductDns建议选.com的域名。 第三步设置子域名添加一个api开头的子域名https://console.cloud.tencent.com/domain，然后添加解析。 第四步登陆服务器安装软件登陆到服务器然后执行以下安装命令。 安装nginx12yum install -y nginxnginx -v 安装nvm12curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bashnvm --version 安装node和pm2、apidoc12345nvm install 8.9.0nvm use 8.9.0node -vnpm -vnpm install -g pm2 apidoc 安装git123456789101112131415yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel taryum install -y gcc-c++ perl-ExtUtils-MakeMakercd /usr/srcwget https://www.kernel.org/pub/software/scm/git/git-2.9.5.tar.gztar xf git-2.9.5.tar.gzcd git-2.9.5make configuremake profix=/usr/gitmake installecho &quot;export PATH=$PATH:/usr/git/bin&quot; &gt;&gt; /etc/profilesource /etc/profilegit --version // 配置gitgit config --global user.name &quot;用户名称&quot;git config --global user.email 电子邮件地址 在服务器上克隆git仓库先进入home路径创建wwwroot文件夹。1234567cd /home &amp;&amp; mkdir wwwrootcd wwwrootgit clone https://github.com/lanpangzhi/novel-api.gitcd novel-apinpm installnpm run docnpm run deploy 这个应用就pm2被启动了。 配置nginx先启动nginx。1nginx http://123.206.45.87 在浏览器输入服务器ip就可以看到nginx已经启动了。 进入nginx配置目录，新建文件。12cd /etc/nginx/conf.dtouch api.langpz.com-8080.conf 如果一台服务器的server比较多，建议用域名和端口做配置文件名。编辑api.langpz.com-8080.conf 配置文件。1vi api.langpz.com-8080.conf 把下面代码复制粘贴过去。12345678910111213141516upstream novel-api &#123; server 127.0.0.1:8080;&#125;server &#123; listen 80; server_name 你自己的域名; location / &#123; proxy_pass http://novel-api; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_redirect off; &#125;&#125; ctrl + c 输入:wq 退出并保存。再执行nginx -s reload 在浏览器输入你的域名就可以看到文档，http://api.langpz.com gzip压缩12cd /etc/nginx/vi nginx.conf 把下面代码复制粘贴过去。123456789101112## gzip压缩gzip on;# ie6不启用gzipgzip_disable &quot;msie6&quot;;gzip_vary on;gzip_proxied any;# 压缩等级 1-9gzip_comp_level 2;gzip_buffers 16 8k;gzip_http_version 1.1;# 为除“text/html”之外的MIME类型启用压缩gzip_types text/plain text/css application/json application/x-javascript image/gif image/jpeg image/png image/tiff image/x-icon application/font-woff application/vnd.ms-fontobject text/javascript; ctrl + c 输入:wq 退出并保存。再执行nginx -s reload。可以去站长之家看你的压缩率http://tool.chinaz.com/gzips/ 隐藏nginx版本号还是修改nginx.conf这个文件12345vi nginx.conf// 把下面代码复制过去# 隐藏nginx版本号server_tokens off; ctrl + c 输入:wq 退出并保存。再执行nginx -s reload。 这里就不显示nginx版本号了。 配置ssl证书https，给你的网站加个小绿锁我用的是腾讯云的免费证书，也可以自己生成。https://cloud.tencent.com/product/ssl?from=qcloudHpHeaderSsl，使用域名免费版。 申请腾讯云ssl证书 直接点下一步，然后用推荐选项验证。申请很快不到十分钟就下来，到时候还会有邮件和短信通知。 下载证书上传到服务器找到腾讯云的ssl证书管理去下载证书。 压缩包里面有三个文件夹找到Nginx这个文件夹。在服务器进入nginx所在目录新建一个文件夹。12cd /etc/nginx/mkdir api.langpz.com 然后把Nginx文件夹里面两个文件上传到服务器/etc/nginx/api.langpz.com 这个文件夹里面。可以下载一个FileZilla软件或者下载一个别的ftp工具，还可以用命令行，我这里下载了FileZilla使用它去上传。 加强 HTTPS 安全性首先在目录 /etc/nginx/api.langpz.com 运行以下代码生成 dhparam.pem 文件12cd /etc/nginx/api.langpz.com openssl dhparam -out dhparam.pem 2048 修改配置文件12cd /etc/nginx/conf.dtouch api.langpz.com-8080.conf 把下面代码覆盖api.langpz.com-8080.conf文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950upstream novel-api &#123; server 127.0.0.1:8080;&#125;# 配置共享会话缓存大小ssl_session_cache shared:SSL:10m;# 配置会话超时时间ssl_session_timeout 10m;# 强制跳转httpsserver &#123; listen 80; server_name api.langpz.com; return 301 https://$server_name$request_uri;&#125;server &#123; listen 443 ssl; server_name api.langpz.com; # 证书文件 ssl_certificate /etc/nginx/api.langpz.com/1_api.langpz.com_bundle.crt; # 私钥文件 ssl_certificate_key /etc/nginx/api.langpz.com/2_api.langpz.com.key; # 设置长连接 keepalive_timeout 70; # 优先采取服务器算法 ssl_prefer_server_ciphers on; # 使用DH文件 ssl_dhparam /etc/nginx/api.langpz.com/dhparam.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 定义算法 ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;; # HSTS策略 add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains;preload&quot; always; # 防XSS攻擊 add_header X-Xss-Protection 1; # 禁止服务器自动解析资源类型 add_header X-Content-Type-Options nosniff; location / &#123; proxy_pass http://novel-api; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_redirect off; &#125;&#125; ctrl + c 输入:wq 退出并保存。再执行nginx -s reload。现在就可以访问https://api.langpz.com。如果访问http协议就会强制跳转到https协议。 SSL安全测试输入你的域名。之前在nginx配置加强 HTTPS 安全性，所以结果是A+。 总结这种部署比较麻烦，部署完发现pm2也有部署功能，2.0用koa.js重构的时候用pm2部署，docker 生成镜像。 参考https://nginx.org/en/docs/https://github.com/creationix/nvmhttps://www.thinkjs.org/zh-cn/doc/3.0/deploy.htmlhttps://www.cnblogs.com/chyingp/p/pm2-documentation.htmlhttp://www.runoob.com/git/git-install-setup.htmlhttps://nginx.rails365.net/chapters/install.htmlhttps://www.cnblogs.com/nuccch/p/7681592.htmlhttps://aotu.io/notes/2016/08/16/nginx-https/index.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"},{"name":"部署","slug":"部署","permalink":"http://blog.langpz.com/tags/部署/"}]},{"title":"使用apidoc文档神器，快速生成api文档","slug":"使用apidoc文档神器，快速生成api文档","date":"2018-05-26T11:13:37.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"使用apidoc文档神器，快速生成api文档.html","link":"","permalink":"http://blog.langpz.com/使用apidoc文档神器，快速生成api文档.html","excerpt":"使用apidoc文档神器，快速生成api文档写完api接口，就需要编写api文档了，如果一个个手写的话就很麻烦，就得使用apidoc只需要通过写注释，就可以快速生成文档了。","text":"使用apidoc文档神器，快速生成api文档写完api接口，就需要编写api文档了，如果一个个手写的话就很麻烦，就得使用apidoc只需要通过写注释，就可以快速生成文档了。 安装第一步先安装全局模块apidoc。1npm install apidoc -g 修改接口的注释找到novel-api项目routes下面的index.js文件，注释修改成如下123456789101112131415161718192021222324252627282930313233343536373839/** * @api &#123;get&#125; /index 请求首页数据 * @apiVersion 1.0.0 * @apiName 获取首页数据 * @apiGroup index * * * @apiSuccess &#123;Number&#125; flag 是否获取到数据 1成功 0失败 * @apiSuccess &#123;Array&#125; books 返回书籍内容 * @apiSuccess &#123;String&#125; msg 返回信息 * * @apiSuccessExample &#123;json&#125; Success-Response: * HTTP/1.1 200 OK * &#123; * &quot;flag&quot;: 1, * &quot;books&quot;: [ * &#123; * &quot;_id&quot;: &quot;5816b415b06d1d32157790b1&quot;, * &quot;title&quot;: &quot;圣墟&quot;, * &quot;author&quot;: &quot;辰东&quot;, * &quot;shortIntro&quot;: &quot;在破败中崛起，在寂灭中复苏。沧海成尘，雷电枯竭，那一缕幽雾又一次临近大地，世间的枷锁被打开了，一个全新的世界就此揭开神秘的一角……&quot;, * &quot;cover&quot;: &quot;http://statics.zhuishushenqi.com/agent/http%3A%2F%2Fimg.1391.com%2Fapi%2Fv1%2Fbookcenter%2Fcover%2F1%2F1228859%2F1228859_fac7917a960547eb953edf0b740cef3a.jpg%2F&quot;, * &quot;site&quot;: &quot;zhuishuvip&quot;, * &quot;majorCate&quot;: &quot;玄幻&quot;, * &quot;minorCate&quot;: &quot;东方玄幻&quot;, * &quot;allowMonthly&quot;: false, * &quot;banned&quot;: 0, * &quot;latelyFollower&quot;: 283375, * &quot;retentionRatio&quot;: &quot;73.42&quot; * &#125; * ], * &quot;msg&quot;: &quot;OK&quot; * &#125; * * * @apiErrorExample Error-Response: * HTTP/1.1 404 Not Found * &#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;rankingId有问题&quot; &#125; */ @api {method} path [title]@api 如果没有@api apidoc会忽略这段注释method 请求的方法path 路径title 标题 @apiVersion version设置文档块的版本。version 版本号 @apiName name定义方法文档块的名称。名称将用于生成的输出中的子导航。name 方法的名称 @apiGroup name定义方法文档块属于哪个组。组将用于生成的输出中的主导航。name 组的名称。也用作导航标题。 @apiSuccess [(group)] [{type}] field [description]成功返回参数。(group) 可选 所有参数将按这个名称分组。没有组，默认Success 200设置。{type} 可选 返回类型field 返回标识符description 描述 @apiParamExample [{type}] [title] example参数请求示例。{type} 可选 响应格式title 示例的简称example 详细的例子 @apiErrorExample [{type}] [title] example错误返回消息的示例，输出为预格式化代码。{type} 可选 响应格式title 示例的简称example 详细的例子 配置npm run doc打开package.json文件增加doc命令配置1&quot;doc&quot;: &quot;apidoc -i routes/ -o public/&quot; routes/ 要输出API文档的文件夹。public/ 输出文档到public文件夹，没有回自动创建。执行 npm run doc访问 http://localhost:3000/ 就可以看到生成好的API文档了。 参考https://github.com/apidoc/apidoc","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"},{"name":"apidoc","slug":"apidoc","permalink":"http://blog.langpz.com/tags/apidoc/"}]},{"title":"使用Express开发小说API接口服务1.0（三）","slug":"使用Express开发小说API接口服务1-0（三）","date":"2018-05-26T10:54:41.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"使用Express开发小说API接口服务1-0（三）.html","link":"","permalink":"http://blog.langpz.com/使用Express开发小说API接口服务1-0（三）.html","excerpt":"使用Express开发小说API接口服务1.0（三）之前发现追书神器API详情页竟然没有下一章和上一章的返回值，只能自己动手封装一下。","text":"使用Express开发小说API接口服务1.0（三）之前发现追书神器API详情页竟然没有下一章和上一章的返回值，只能自己动手封装一下。 app.js 增加错误处理1234567891011121314151617// catch 404 and forward to error handlerapp.use(function (req, res, next) &#123; const err = new Error(&apos;Not Found&apos;); err.status = 404; next(err);&#125;);// error handlerapp.use(function (err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(&apos;env&apos;) === &apos;development&apos; ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(&apos;error&apos;);&#125;); 这些代码放到module.exports = app; 上面就可以了。 列表页增加返回ID找到routes/chapter.js 29行替换1res.send(JSON.stringify(&#123; &quot;flag&quot;: 1,&quot;id&quot;: body._id, &quot;chapters&quot;: body.chapters, &quot;msg&quot;: &quot;OK&quot; &#125;)); 详情页增加上一章和下一章的返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071let express = require(&apos;express&apos;);let request = require(&apos;request&apos;);let common = require(&apos;../common/common.json&apos;); // 引用公共文件let router = express.Router();/** 获取小说文章内容 返回小说文章内容 param link &#123;String&#125; 是小说文章列表接口 chapters[0].link http://chapter2.zhuishushenqi.com/chapter/$&#123;link&#125;*/router.get(&apos;/&apos;, function (req, res, next) &#123; if (!req.query.link) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入link...&quot; &#125;)); &#125; // req.query.link 编码转义 let link = encodeURIComponent(req.query.link); request.get(`$&#123;common.CHAPTER&#125;/chapter/$&#123;link&#125;`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok)&#123; // 再次请求列表页获取上一页和下一页 if(req.query.id)&#123; // req.query.id 编码转义 let id = encodeURIComponent(req.query.id); let n = parseInt(req.query.n); if (isNaN(n))&#123; n = 0; &#125; request.get(`$&#123;common.API&#125;/atoc/$&#123;id&#125;?view=chapters`, function (err, response, body2) &#123; if (err) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; if (body2 == &quot;wrong param&quot;)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入错误的ID...&quot; &#125;)); &#125;else&#123; // 解析返回的数据 body2 = JSON.parse(body2); // 检查页码是否超过小说的章节数 if(n &gt; body2.chapters.length - 1)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入的页码过大&quot; &#125;)); &#125;else&#123; // 如果有上一页或者下一页就返回link否则返回false let prev,next; body2.chapters[n - 1] ? prev = body2.chapters[n - 1].link : prev = false; body2.chapters[n + 1] ? next = body2.chapters[n + 1].link : next = false; if (body2.chapters.length &gt; 0) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 1,&quot;id&quot;: id, &quot;chapter&quot;: body.chapter, &quot;prev&quot;: prev,&quot;next&quot;: next, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125; &#125; &#125; &#125;); &#125;else&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;chapter&quot;: body.chapter, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125; &#125;else&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入link有错误&quot; &#125;)); &#125; &#125;);&#125;);module.exports = router; 访问http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037&amp;n=2648&amp;id=577b6c81ccb7bf00499d036c新增n和id参数。n 代表是第几页。id 是书籍ID。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"}]},{"title":"使用Express开发小说API接口服务1.0(二)","slug":"使用Express开发小说API接口服务-二","date":"2018-05-18T13:26:05.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"使用Express开发小说API接口服务-二.html","link":"","permalink":"http://blog.langpz.com/使用Express开发小说API接口服务-二.html","excerpt":"使用Express开发小说API接口服务1.0(二)之前完成了首页和搜索的接口，现在就开始写剩下的接口。","text":"使用Express开发小说API接口服务1.0(二)之前完成了首页和搜索的接口，现在就开始写剩下的接口。 获取小说源因为追书神器正版源是收费加密的，所以只能使用盗版源，所以要封装一个获取小说源的接口。修改app.js 文件路由中间件配置，增加一个路由12let sourceRouter = require(&apos;./routes/source&apos;);app.use(&apos;/source&apos;, sourceRouter); 在routes下面新建 source.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546let express = require(&apos;express&apos;);let request = require(&apos;request&apos;);let common = require(&apos;../common/common.json&apos;); // 引用公共文件let router = express.Router();/** 获取小说源 返回盗版源和正版源 param id &#123;String&#125; 是首页和搜索返回接口 books[i].id param n &#123;Number || String&#125; 使用第几个源，可以不用传参默认 1 http://api.zhuishushenqi.com/atoc?view=summary&amp;book=$&#123;bookID&#125;*/router.get(&apos;/&apos;, function (req, res, next) &#123; if (!req.query.id) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入ID...&quot; &#125;)); &#125; // req.query.id 编码转义 let id = encodeURI(req.query.id); request.get(`$&#123;common.API&#125;/atoc?view=summary&amp;book=$&#123;id&#125;`, function (err, response, body)&#123; if(err)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); // 判断是否返回内容 if (body.length == 0)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;没有获取到小说源，换个小说看吧&quot; &#125;)); &#125; // 第一个源是正版源，是收费加密的，所以默认选中第二个源 let n = parseInt(req.query.n); if (isNaN(n) || n == 0)&#123; n = 1; &#125; // 判断n是否大于源数据的长度 if (n &gt;= body.length)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;n的参数值不正确，没有那个源&quot; &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;books&quot;: body[n], &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125; &#125;);&#125;);module.exports = router; 访问http://localhost:3000/source/?id=50864bf69dacd30e3a000014&amp;n=3 就可以看到返回第四个源的数据。 小说文章列表修改app.js 文件路由中间件配置，增加一个路由12let chapterRouter = require(&apos;./routes/chapter&apos;);app.use(&apos;/chapter&apos;, chapterRouter); 在routes下面新建 chapter.js123456789101112131415161718192021222324252627282930313233343536let express = require(&apos;express&apos;);let request = require(&apos;request&apos;);let common = require(&apos;../common/common.json&apos;); // 引用公共文件let router = express.Router();/** 获取小说文章列表 返回小说文章列表 param id &#123;String&#125; 是小说源接口 books.id http://api.zhuishushenqi.com/atoc/$&#123;id&#125;?view=chapters*/router.get(&apos;/&apos;, function (req, res, next) &#123; if (!req.query.id)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入ID...&quot; &#125;)); &#125; // req.query.id 编码转义 let id = encodeURIComponent(req.query.id); request.get(`$&#123;common.API&#125;/atoc/$&#123;id&#125;?view=chapters`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; if (body == &quot;wrong param&quot;)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入错误的ID...&quot; &#125;)); &#125;else&#123; // 解析返回的数据 body = JSON.parse(body); if (body.chapters.length &gt; 0) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;chapters&quot;: body.chapters, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125; &#125; &#125;);&#125;);module.exports = router; 访问http://localhost:3000/chapter/?id=57416370ccc94e4b41df80cc 就可以看到数据。id小说源接口返回的id。 小说文章内容修改app.js 文件路由中间件配置，增加一个路由12let articleRouter = require(&apos;./routes/article&apos;);app.use(&apos;/article&apos;, articleRouter); 在routes下面新建 article.js12345678910111213141516171819202122232425262728293031323334let express = require(&apos;express&apos;);let request = require(&apos;request&apos;);let common = require(&apos;../common/common.json&apos;); // 引用公共文件let router = express.Router();/** 获取小说文章内容 返回小说文章内容 param link &#123;String&#125; 是小说文章列表接口 chapters[0].link http://chapter2.zhuishushenqi.com/chapter/$&#123;link&#125;*/router.get(&apos;/&apos;, function (req, res, next) &#123; if (!req.query.link) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入link...&quot; &#125;)); &#125; // req.query.link 编码转义 let link = encodeURIComponent(req.query.link); request.get(`$&#123;common.CHAPTER&#125;/chapter/$&#123;link&#125;`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;chapter&quot;: body.chapter, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入link有错误&quot; &#125;)); &#125; &#125;);&#125;);module.exports = router; 访问http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037 就可以看到数据。 排行榜修改app.js 文件路由中间件配置，增加一个路由12let rankingRouter = require(&apos;./routes/ranking&apos;);app.use(&apos;/ranking&apos;, rankingRouter); 在routes下面新建 ranking.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let express = require(&apos;express&apos;);let request = require(&apos;request&apos;);let common = require(&apos;../common/common.json&apos;); // 引用公共文件let router = express.Router();/** 获取排行榜 返回排行榜 param id &#123;String&#125; 没有传参数就是获取全部榜单，否则根据参数获取榜单 http://api.zhuishushenqi.com/ranking/gender http://api.zhuishushenqi.com/ranking/$&#123;id&#125;*/router.get(&apos;/&apos;, function (req, res, next) &#123; // 获取全部榜单 request.get(`$&#123;common.API&#125;/ranking/gender`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok) &#123; let ranking = &#123; male: body.male, picture: body.picture, epub: body.epub, female: body.female &#125;; res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;ranking&quot;: ranking, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125; else &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;出错了&quot; &#125;)); &#125; &#125;);&#125;);router.get(&apos;/:id&apos;, function (req, res, next) &#123; if (req.params.id) &#123; // req.param.id 编码转义 let id = encodeURIComponent(req.params.id); // 根据id获取榜单 request.get(`$&#123;common.API&#125;/ranking/$&#123;id&#125;`, function (err, response, body) &#123; if (err) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; // 解析返回的数据 body = JSON.parse(body); if (body.ok) &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;ranking&quot;: body.ranking, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125; else &#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入id错误&quot; &#125;)); &#125; &#125;); &#125;else&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;id没有传&quot; &#125;)); &#125;&#125;);module.exports = router; 分别访问http://localhost:3000/ranking/ 和 http://localhost:3000/ranking/54d43437d47d13ff21cad58b 就可以获取到榜单的数据。1.0版本的开发就告于段落了。github仓库访问地址https://github.com/lanpangzhi/novel-api 参考https://github.com/expressjs/morganhttps://juejin.im/entry/593a3fdf61ff4b006c737ca4https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"}]},{"title":"使用Express开发小说API接口服务1.0（一）","slug":"使用Express开发小说API接口服务","date":"2018-05-17T15:10:56.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"使用Express开发小说API接口服务.html","link":"","permalink":"http://blog.langpz.com/使用Express开发小说API接口服务.html","excerpt":"使用Express开发小说API接口服务1.0（一）1.0版本技术栈使用express-generator、express、request、morgan、file-stream-rotator。接口用追书神器API。目前接口设计有首页，小说详情页，搜索，小说文章列表页，排行API。","text":"使用Express开发小说API接口服务1.0（一）1.0版本技术栈使用express-generator、express、request、morgan、file-stream-rotator。接口用追书神器API。目前接口设计有首页，小说详情页，搜索，小说文章列表页，排行API。 github创建仓库先创建一个仓库放文件 然后克隆创建好的仓库1git clone https://github.com/lanpangzhi/novel-api.git 安装 express-generator 快速生成项目1npm install -g express-generator 然后再之前克隆仓库的上一级目录执行12345678express --no-view novel-apicd novel-apinpm install npm install request file-stream-rotator -S// Linux MacOSDEBUG=novel-api:* &amp; npm start// windows set DEBUG=novel-api:* &amp; npm start 生成好的目录结构和文件 设置cors 跨域打开项目根目录app.js,放在路由上面。12345678app.all(&apos;*&apos;, function (req, res, next) &#123; res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;); res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;); res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;) res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;); next()&#125;); 日志写入本地文件按时间分割log日志并写入本地磁盘，需要在app.js文件中引入fs和file-stream-rotator模块。12345678910111213141516171819let fs = require(&apos;fs&apos;); let FileStreamRotator = require(&apos;file-stream-rotator&apos;); // 日志按时间分割模块// 下面代码写在var app = express();下面let logDir = path.join(__dirname, &apos;log&apos;);// 检查是否存在logDir这个目录没有则创建fs.existsSync(logDir) || fs.mkdirSync(logDir);// 日志分割流let accessLogStream = FileStreamRotator.getStream(&#123; date_format: &apos;YYYYMMDD&apos;, filename: path.join(logDir, &apos;access-%DATE%.log&apos;), frequency: &apos;daily&apos;, verbose: false&#125;);// 日志中间件app.use(logger(&apos;combined&apos;, &#123; stream: accessLogStream &#125;)); 创建公共文件项目根目录创建common文件夹，再里面再新建一个common.json文件12345&#123; &quot;API&quot;: &quot;http://api.zhuishushenqi.com&quot;, &quot;PIC&quot;: &quot;http://statics.zhuishushenqi.com&quot;, &quot;CHAPTER&quot;: &quot;http://chapter2.zhuishushenqi.com&quot;&#125; API域名: http://api.zhuishushenqi.com图片域名: http://statics.zhuishushenqi.com章节域名: http://chapter2.zhuishushenqi.com 首页接口1.0版本首页接口直接返回最热榜前20条数据。修改app.js 文件路由中间件配置1app.use(&apos;/index&apos;, indexRouter); 修改routes/index.js 文件12345678910111213141516171819202122232425262728293031323334let express = require(&apos;express&apos;);let request = require(&apos;request&apos;);let common = require(&apos;../common/common.json&apos;); // 引用公共文件let router = express.Router();/** 首页数据追书最热榜 Top100 获取单一排行榜 http://api.zhuishushenqi.com/ranking/&#123;rankingId&#125;*/router.get(&apos;/&apos;, function(req, res, next) &#123; // 请求追书最热榜 Top100 request.get(`$&#123;common.API&#125;/ranking/54d42d92321052167dfb75e3`, function (error, response, body) &#123; if (error)&#123; res.send(JSON.stringify(&#123;&quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot;&#125;)); &#125; // 解析返回数据取前20条，并添加图片url链接 body = JSON.parse(body); if (body.ok)&#123; let books = body.ranking.books.slice(0, 19); books.forEach(element =&gt; &#123; element.cover = common.PIC + element.cover; &#125;); res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;books&quot;: books, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;rankingId有问题&quot; &#125;)); &#125; &#125;);&#125;);module.exports = router; 访问http://localhost:3000/index 就可以看到返回的数据了。 搜索接口1.0版本的搜索接口只取前40条数据，可以模糊查询。修改app.js 文件路由中间件配置，把users删掉。12let searchRouter = require(&apos;./routes/search&apos;);app.use(&apos;/search&apos;, searchRouter); 然后把routes文件夹下面的users.js删除，新建search.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546let express = require(&apos;express&apos;);let request = require(&apos;request&apos;);let common = require(&apos;../common/common.json&apos;); // 引用公共文件let router = express.Router();/** 模糊搜索接口 返回模糊搜索前40条数据 http://api.zhuishushenqi.com/book/fuzzy-search?query=&#123;name&#125;*/router.get(&apos;/&apos;, function(req, res, next) &#123; // 判断query参数有没有传递过来 if (req.query.query)&#123; // req.query.query 编码转义 let query = encodeURIComponent(req.query.query); request.get(`$&#123;common.API&#125;/book/fuzzy-search?query=$&#123;query&#125;`, function (error, response, body) &#123; if (error)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; // 解析返回数据 body = JSON.parse(body); if (body.ok)&#123; if (body.books.length == 0)&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;没有找到书籍，换个名字试试吧。&quot; &#125;)); &#125; // 取前40条，并添加图片url链接 let books = body.books.slice(0, 39); books.forEach(element =&gt; &#123; element.cover = common.PIC + element.cover; &#125;); res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;books&quot;: books, &quot;msg&quot;: &quot;OK&quot; &#125;)); &#125;else&#123; res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;)); &#125; &#125;); &#125;else&#123; res.send(JSON.stringify(&#123;&quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入query参数&quot;&#125;)); &#125; &#125;);module.exports = router; 访问http://localhost:3000/search/?query=遮天 就可以看到返回的数据了。 参考https://github.com/expressjs/morganhttps://juejin.im/entry/593a3fdf61ff4b006c737ca4https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"API","slug":"API","permalink":"http://blog.langpz.com/tags/API/"}]},{"title":"使用travis-ci自动构建Hexo","slug":"使用travis-ci自动构建Hexo","date":"2018-05-15T16:30:49.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"使用travis-ci自动构建Hexo.html","link":"","permalink":"http://blog.langpz.com/使用travis-ci自动构建Hexo.html","excerpt":"使用travis-ci自动构建Hexo持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。","text":"使用travis-ci自动构建Hexo持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。 构建流程本地写完文章 =&gt; push github =&gt; GitHub触发Travis CI构建 =&gt; 执行命令 =&gt; 部署 =&gt; 完成。 用github登陆travis-cihttps://travis-ci.com然后添加到你要激活的存储库。 然后选择你要使用的仓库，我这里选择的是lanpangzhi.github.io，我放hexo博客的仓库。 然后生成github和coding的Token。先生成github的Token。https://github.com/settings/tokens点击Generate new token。 然后生成Token。 开始生成coding的Token。 点击新建令牌。 复制令牌。 登陆travis-ci把github和coding的Token复制到环境变量。https://travis-ci.com/ 点击Settings。添加CI_TOKEN和CO_TOKEN环境变量。CI_TOKEN是github的Token。CO_TOKEN是coding的Token。 在项目根目录新建.travis.yml 文件1234567891011121314151617181920212223242526272829303132333435language: node_jsnode_js:- 8.9.0cache: directories: - node_modulesbefore_install:- npm install hexo-cli -ginstall:- npm installscript:- hexo clean- hexo generateafter_script: - cd ./public - git init - git config user.name &quot;github用户名&quot; - git config user.email &quot;github邮箱&quot; - git add . - git commit -m &quot;TravisCI 自动部署&quot; # Github Pages - git push --force --quiet &quot;https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master # Coding Pages - git push --force --quiet &quot;https://coding用户名:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;&quot; master:masterbranches: only: - indigo 这里替换你要监听的分支env: global: # Github Pages - GH_REF: github.com/lanpangzhi/lanpangzhi.github.io 这里替换你的github仓库地址 # Coding Pages - CO_REF: git.coding.net/bule/bule.coding.me.git 这里替换你的coding仓库地址 然后提交github，travis-ci就会自动构建了。现在写博客只需要两步操作，第一步 hexo new “新的文章”，第二步提交到github。travis-ci会帮你自动部署的。省去了 hexo clean hexo g -d 的环节。 看到这张图就代表成功了。 如果使用git子模块的话请使用https地址，或者在.travis.yml文件禁用子模块，否则构建会报错，提示没有权限。参考https://docs.travis-ci.com/user/for-beginnershttps://zh.wikipedia.org/wiki/Travis_CIhttps://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744https://blog.csdn.net/qinyuanpei/article/details/79388983","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"},{"name":"travis-ci","slug":"travis-ci","permalink":"http://blog.langpz.com/tags/travis-ci/"},{"name":"自动构建","slug":"自动构建","permalink":"http://blog.langpz.com/tags/自动构建/"},{"name":"持续集成","slug":"持续集成","permalink":"http://blog.langpz.com/tags/持续集成/"}]},{"title":"使用express-generator快速生成express应用","slug":"使用express-generator快速生成express应用","date":"2018-05-14T16:08:03.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"使用express-generator快速生成express应用.html","link":"","permalink":"http://blog.langpz.com/使用express-generator快速生成express应用.html","excerpt":"使用express-generator快速生成express应用express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。","text":"使用express-generator快速生成express应用express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。 安装1npm install -g express-generator 需要全局安装。 使用在要创建应用的文件夹下面执。1express -e myapp -e： 使用ejs模板myapp： 应用名字 然后安装依赖项：12cd myappnpm install 执行应用1set DEBUG=myapp:* &amp; npm start 生成完应用的时候会有提示因为我是Windows系统所以提示set。MacOS 或 Linux 上不用使用set1DEBUG=myapp:* npm start 然后在浏览器中输入 http://localhost:3000/ 以访问此应用程序。可以根据自己的需要修改文件，来满足自己项目的需要。 更多参数12345678910 --version 输出版本号-e, --ejs 添加ejs引擎支持 --pug 添加pug引擎支持 --hbs 添加handlebars引擎支持-H, --hogan 添加hogan.js引擎支持-v, --view &lt;engine&gt; 添加以下模板引擎支持(dust|ejs|hbs|hjs|jade|pug|twig|vash) 默认jade --no-view 使用静态HTML代替视图模板引擎-c, --css &lt;engine&gt; 添加样式扩展语言 (less|stylus|compass|sass) 默认css --git 添加 .gitignore 忽略文件-h, --help 输出帮助信息 参考https://github.com/expressjs/generator","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"express-generator","slug":"express-generator","permalink":"http://blog.langpz.com/tags/express-generator/"}]},{"title":"node爬虫","slug":"node爬虫","date":"2018-05-12T15:37:42.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"node爬虫.html","link":"","permalink":"http://blog.langpz.com/node爬虫.html","excerpt":"node爬虫什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。","text":"node爬虫什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。 项目分析爬取http://top.zhaopin.com 智联网站上的全国的竞争最激烈三个月内前十的岗位。不需要定时爬取。使用request和cheerio模块。node版本7.6.0、npm版本4.1.2 安装1npm install request cheerio -S request 模块是一个简化的HTTP客户端。cheerio 模块专为服务器设计的核心jQuery的快速，灵活和精益的实现。可以把爬到的内容和jQuery一样使用。 核心代码1234567891011121314151617181920212223// app.jsconst request = require(&apos;request&apos;);const cheerio = require(&apos;cheerio&apos;);// 发起请求request(&apos;http://top.zhaopin.com&apos;, (error, response, body) =&gt; &#123; if(error)&#123; console.error(error); &#125; let json = &#123;&#125;; // 获取到的内容放到cheerio模块 const $ = cheerio.load(body); // jQuery 遍历 #hotJobTop .topList li 是通过http://top.zhaopin.com 分析页面结构得到的 $(&apos;#hotJobTop .topList li&apos;).each(function (index) &#123; let obj = json[index] = &#123;&#125;; obj.name = $(this).find(&apos;.title&apos;).text().trim(); obj.num = $(this).find(&apos;.paddingR10&apos;).text().trim(); &#125;); // 打印数据 console.log(json);&#125;); 执行 node app.js 就会得到如下结果。12345678910[ &#123; name: &apos;Java开发工程师&apos;, num: &apos;340538人/天&apos; &#125;, &#123; name: &apos;软件工程师&apos;, num: &apos;220873人/天&apos; &#125;, &#123; name: &apos;销售代表&apos;, num: &apos;175053人/天&apos; &#125;, &#123; name: &apos;会计/会计师&apos;, num: &apos;168225人/天&apos; &#125;, &#123; name: &apos;行政专员/助理&apos;, num: &apos;150913人/天&apos; &#125;, &#123; name: &apos;WEB前端开发&apos;, num: &apos;140979人/天&apos; &#125;, &#123; name: &apos;助理/秘书/文员&apos;, num: &apos;139098人/天&apos; &#125;, &#123; name: &apos;软件测试&apos;, num: &apos;136399人/天&apos; &#125;, &#123; name: &apos;人力资源专员/助理&apos;, num: &apos;123482人/天&apos; &#125;, &#123; name: &apos;用户界面（UI）设计&apos;, num: &apos;107505人/天&apos; &#125; ] 一个简单的爬虫就写好了，看看前十有没有你从事的岗位吧！ 参考https://github.com/request/requesthttps://github.com/cheeriojs/cheerio","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"爬虫","slug":"爬虫","permalink":"http://blog.langpz.com/tags/爬虫/"}]},{"title":"node连接MySQL","slug":"node连接MySQL","date":"2018-05-10T15:40:04.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"node连接MySQL.html","link":"","permalink":"http://blog.langpz.com/node连接MySQL.html","excerpt":"node连接MySQL之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。","text":"node连接MySQL之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。 安装1npm install mysql 连接1234567891011121314151617const mysql = require(&apos;mysql&apos;);let connection = mysql.createConnection(&#123; host : &apos;localhost&apos;, user : &apos;root&apos;, password : &apos;password&apos;, database : &apos;test&apos;&#125;);connection.connect(function(err) &#123; if (err) &#123; console.error(&apos;连接出错: &apos; + err.stack); return; &#125; console.log(&apos;连接成功 id &apos; + connection.threadId);&#125;); host：连接的服务器user：用户名默认是rootpassword：之前设置的MySQL密码database： 要连接的库 常用的SQL语句SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。 增1INSERT INTO user (username, pass) VALUES (&apos;blog.langpz.com&apos;, &apos;123456&apos;); INSERT INTO 表名称 VALUES (值1, 值2,….)指定所要插入数据的列INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….) 删1DELETE FROM user WHERE id = 0 DELETE FROM 表名称 WHERE 列名称 = 值不加WHERE会删除所有行WHERE子句用于规定选择的标准。 改1UPDATE user SET pass = &apos;bbb&apos; WHERE username = &apos;张三&apos; UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 查1SELECT * FROM user SELECT 列名 FROM 表名 注： * 代表全部 node操作MySQL查询123456connection.query(&apos;SELECT * FROM user WHERE username = &quot;blog.langpz.com&quot;&apos;, (err, results, fields) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 删除123456connection.query(&apos;DELETE FROM user WHERE id = 1&apos;, (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 增加123456connection.query(&apos;INSERT INTO user(username, pass) VALUES(?, ?)&apos;,[&apos;lan&apos;, &apos;abc&apos;], (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 修改123456connection.query(&apos;UPDATE user SET pass = &quot;bbb&quot; WHERE username = &quot;lan&quot;&apos;, (err, results) =&gt; &#123; if(err)&#123; console.log(err); &#125; console.log(results);&#125;) 终止连接1234connection.end(function(err) &#123; // The connection is terminated now&#125;);connection.destroy(); 调用这两个方法都可以。基本操作就是这个流程，可以通过路由封装接口，写一个CRUD应用，mysql模块更多参数可以去看github。 参考https://github.com/mysqljs/mysql","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.langpz.com/tags/MySQL/"}]},{"title":"Windows下安装MongoDB","slug":"Windows下安装MongoDB","date":"2018-05-08T15:30:32.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"Windows下安装MongoDB.html","link":"","permalink":"http://blog.langpz.com/Windows下安装MongoDB.html","excerpt":"Windows下安装MongoDBMongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。","text":"Windows下安装MongoDBMongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。 MongoDB特点和关系型数据库比较，面向文档的数据库不再有“行”（row）的概念，取而代之的是更为灵活的“文档”（document）模型。通过再文档中嵌入文档和数组，面向文档的方法能够仅使用一条记录来表现复杂的层次关系。另外，不再有预定义模式，文档的键（key）和值（value）不再是固定的类型和大小。由于没有固定的模式，根据需要添加或删除字段变得更容易。可以进行快速迭代，所以开发进程得到加快。 MongoDB基本概念文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行。集合(collection)可以看作是一个拥有动态模式(dynamic schema)的表。MongoDB的一个实例可以拥有多个相互独立的数据库(database)，每一个数据库都拥有自己的集合。每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。 下载和安装下载地址 点击下载，下载完安装，用默认设置。 运行MongoDB命令提示符（cmd）执行，具体路径需要看安装的版本，我的是3.6版本。12cd C:\\Program Files\\MongoDB\\Server\\3.6\\binmongod --dbpath d:\\db 控制台会输出一些东西，没有报错MongoDB就启动了。这样启动比较麻烦，每次都要启动，所以可以把它注册成windows 的服务123// 使用管理员权限运行mongod --install --dbpath d:\\data\\db --logpath d:\\data\\log\\log.txtnet start MongoDB // 启动服务 12services.msc // 查看服务net stop mongodb // 停止服务 删除服务1mongod --remove --serviceName MongoDB // MongoDB是服务名 MongoDB 还可以通过配置文件启动可以去官网查看https://docs.mongodb.com/manual/reference/configuration-options/ 连接MongoDB在打开一个命令提示符（cmd）之前运行的MongoDB那个不要关闭，因为没有注册成windows的服务，关闭就找不到数据库了。12cd C:\\Program Files\\MongoDB\\Server\\3.6\\binmongo 这样就链接上数据库了，当然还会输出一大堆东西。 操作MongoDB我们先创建一个数据库，再刚才连接MongoDB的cmd执行1use test02 创建一个test02的数据库并切换过去。db变量指向当前数据库。向集合里插入文档，之前也讲了MongoDB没有预定义模式，所以不用新建表和表结构了。insert方法 把一条文档保存到集合里。1db.user_table.insert(&#123;&quot;name&quot;, &quot;lanpangzhi&quot;, &quot;age&quot;: 18&#125;) 查看集合里面的文档。find和findOne方法可以用于查询集合里的文档。只想查看一个文件，可以用findOne12db.user_table.find()db.user_table.findOne() find和findOne还可以接受一个查询文档作为限定条件。1db.user_table.find(&#123;&quot;name&quot;: &quot;lanpangzhi&quot;&#125;) 更新集合里面的文档update方法接受（至少）两个参数：第一个是限定条件（用于匹配待更新的文档），第二个是新的文档。1db.user_table.update(&#123;name: lanpangzhi&#125;,&#123;&quot;name&quot;: &quot;lanpangzhi&quot;, &quot;age&quot;: 18, &quot;sex&quot;: 1&#125;); 删除集合里面的文档remove方法可将数据库的集合永久删除，如果不加参数默认把集合里面所有的文档删除。它可以接受一个限定条件的文档作为参数。1db.user_table.remove(&#123;&quot;name&quot;: &quot;aaa&quot;&#125;)","categories":[],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://blog.langpz.com/tags/MongoDB/"},{"name":"Windows","slug":"Windows","permalink":"http://blog.langpz.com/tags/Windows/"}]},{"title":"Windows下安装MySQL","slug":"Windows下安装MySQL","date":"2018-05-08T11:02:20.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"Windows下安装MySQL.html","link":"","permalink":"http://blog.langpz.com/Windows下安装MySQL.html","excerpt":"Windows下安装MySQLMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。","text":"Windows下安装MySQLMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。 下载下载地址 点击，进入页面。注：MySQL安装程序是32位的，但会安装32位和64位二进制文件。 点击download然后跳转到页面。可以不需要登陆和注册也可以下载。 再点击，安装程序就下载了。 安装打开安装程序，勾选同意协议，点击下一步(Next) 现在只安装MySQL的服务端，点击下一步然后安装。设置MySQL密码，继续下一步。然后完成，其余配置都是用默认配置。 使用Navicat for MySQL 管理MySQL下载地址可以用它去管理MySQL。新建库，新建表，修改数据删除数据。 MySQL基本概念库： 文件夹-用来管理，无法存放数据，一个库可以存放很多张表。表： 文件-存放数据用的。列: 一列(数据元素) 包含了相同的数据, 例如用户的数据。行：一行是一组相关的数据，例如一条用户名和密码的数据。主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。外键：外键用于关联两个表。 MySQL常用数据类型 数据类型 说明 INT 整数 FLOAT 浮点数 DATE 日期值 DATETIME 混合日期和时间值 TIME 时间值或持续时间 VARCHAR 变长字符串 CHAR 定长字符串 参考https://github.com/jaywcjlove/handbook/blob/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.langpz.com/tags/Windows/"},{"name":"MySQL","slug":"MySQL","permalink":"http://blog.langpz.com/tags/MySQL/"}]},{"title":"Express路由","slug":"Express路由","date":"2018-05-07T17:50:08.000Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"Express路由.html","link":"","permalink":"http://blog.langpz.com/Express路由.html","excerpt":"Express路由之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。","text":"Express路由之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。 一个网站下面可能有很多地址例如:www.langpz.com/aaauser/www.langpz.com/user/aaawww.langpz.com/user/bbbwww.langpz.com/user/cccvip/www.langpz.com/vip/aaawww.langpz.com/vip/bbbwww.langpz.com/vip/ccc等等。。。咱们可以拆分成vip和user两个目录目录下再放子路由。先安装express 然后在项目根目录建一个app.js和routers文件夹，routers文件夹里面再建一个index.js文件和vip、user两个目录，两个目录下面分别建立index.js文件。1234567891011// app.jsconst express = require(&apos;express&apos;);const routers = require(&apos;./routers&apos;); //引入路由let app = express();app.use(&apos;/vip&apos;, routers.vip); // 设置/vip路由中间件app.use(&apos;/user&apos;, routers.user); // 设置/user路由中间件app.listen(8000); 12345678// routers/index.jslet vip = require(&apos;./vip&apos;); // 引入vip文件下面的路由let user = require(&apos;./user&apos;); // 引入user文件下面的路由// 导出路由module.exports = &#123; vip, user&#125;; 12345678910111213141516171819// routers/vip/index.jsconst express = require(&apos;express&apos;); // 必须要引入expresslet routerVip = express.Router(); // 创建router实例// 添加路由配置routerVip.get(&apos;/&apos;, (req, res) =&gt; &#123; res.send(&apos;我是vip根目录&apos;)&#125;);routerVip.get(&apos;/aaa&apos;, (req, res) =&gt; &#123; res.send(&apos;我是vip/aaa目录&apos;)&#125;);routerVip.get(&apos;/bbb&apos;, (req, res) =&gt; &#123; res.send(&apos;我是vip/bbb目录&apos;)&#125;);// 导出路由module.exports = routerVip; 1234567891011121314151617181920// routers/user/index.jsconst express = require(&apos;express&apos;); // 必须要引入expresslet routerUser = express.Router(); // 创建router实例// 添加路由配置routerUser.get(&apos;/&apos;, (req, res) =&gt;&#123; res.send(&apos;我是user根目录&apos;)&#125;);routerUser.get(&apos;/aaa&apos;, (req, res) =&gt; &#123; res.send(&apos;我是user/aaa目录&apos;)&#125;);routerUser.get(&apos;/bbb&apos;, (req, res) =&gt; &#123; res.send(&apos;我是user/bbb目录&apos;)&#125;);// 导出路由module.exports = routerUser; 然后执行 node app.js 再浏览器输入http://localhost:8000/user/aaa、http://localhost:8000/vip/aaa，就可以来回切换路由了，如果新增了一个路由模块就在routers文件夹下，再新建文件夹划分路由，这样路由文件比较清晰，后期维护起来也方便。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"路由","slug":"路由","permalink":"http://blog.langpz.com/tags/路由/"}]},{"title":"Express框架cookie和session","slug":"Express框架cookie和session","date":"2018-05-06T17:32:54.000Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"Express框架cookie和session.html","link":"","permalink":"http://blog.langpz.com/Express框架cookie和session.html","excerpt":"Express框架cookie和sessionHTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。","text":"Express框架cookie和sessionHTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。 cookiecookie存在浏览器端，每次请求都会带上。 缺点：不安全(用户可以随便串改)，大小（4k）。 sessionsession只存在服务器端。 优点：容量不限，比较安全（用户接触不到）。 session实现是基于cookie的。风险：session_id 被泄露漏 session劫持。 提醒用户不在在控制台输入(console)输入代码。 session_id 足够复杂，定期更换。 Express操作cookie先安装cookie-parser。1npm install cookie-parser -S 123456789101112131415// app.jsconst express = require(&apos;express&apos;);const cookieParser = require(&apos;cookie-parser&apos;);let app = express();app.use(cookieParser()); // 设置cookieParser 中间件app.get(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.cookies); // 获取cookie res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;); // 设置cookie res.send(&apos;OK&apos;);&#125;);app.listen(8000); 在cmd执行 node app.js 浏览器输入http://localhost:8000/ 第一次控制台输出{}，再刷新就输出{user: ‘lanpangzhi’ }。现在就能获取和设置cookie了，但是有个问题，浏览器执行document.cookie = “user=aaa”,浏览器再刷新控制台就会输出{user: ‘aaa’ }。这样使用cookie不安全，敏感信息容易被篡改，所以要使用带签名的cookie。 带签名的cookie123456789101112131415161718// app.jsconst express = require(&apos;express&apos;);const cookieParser = require(&apos;cookie-parser&apos;);let app = express();app.use(cookieParser(&apos;abc123456abc&apos;)); // 设置cookieParser 中间件 使用签名必须要设置字符串。app.get(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.cookies); // 获取cookie console.log(req.signedCookies); // 获取带签名的cookie res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;, &#123; signed: true // 设置带签名的cookie &#125;); res.send(&apos;OK&apos;);&#125;);app.listen(8000); 再执行，就会发现浏览器cookie的值变成了s%3Alanpangzhi.i6hEUuhD%2Fd0miBMsGyRdktiDFmi%2BYfiJhQTcqKpQqIc ，再修改cookie的值，控制台就会输出{ user: false }，这样cookie就不会被简单的篡改了。 req.cookies 获取cookie。res.cookie(name, value [, options]); name: cookie的名称(string)。 value: cookie的值，(string or object)。 options：options参数是一个可以具有以下属性的对象。 如下 值 类型 说明 domain String cookie的域名。 默认为网站的域名。 encode Function 用于cookie值编码的同步函数。 默认为encodeURIComponent。 expires Date cookie的有效期（如果未指定或设置为0），则创建会话cookie。 httpOnly Boolean 将cookie标记为仅可由Web服务器访问。默认false maxAge Number 设置cookie的到期时间、相对于当前时间的到期时间（以毫秒为单位）。 path String cookie的路径。 默认为“/” secure Boolean 将cookie标记为仅与HTTPS一起使用。默认false signed Boolean 对cookie进行签名。默认false Express操作session先安装cookie-session。1npm install cookie-session -S 1234567891011121314151617181920// app.jsconst express = require(&apos;express&apos;);const cookieSession = require(&apos;cookie-session&apos;);let app = express();app.use(cookieSession(&#123; secret: &apos;aaaa&apos;&#125;)); // 设置cookieSession中间件app.get(&apos;/&apos;, (req, res) =&gt; &#123; if (req.session[&apos;num&apos;]) &#123; req.session[&apos;num&apos;]++; &#125;else&#123; req.session[&apos;num&apos;] = 1; // 设置session &#125; res.send(`访问$&#123;req.session[&quot;num&quot;]&#125;次`);&#125;);app.listen(8000); 在cmd执行 node app.js 浏览器输入http://localhost:8000/ 刷新浏览器就可以看到访问几次，把所有浏览器都关闭session就失效了，再进入页面就从第一次开始了。更多方法还有详细参数可以去github自行参考。 参考http://expressjs.com/en/4x/api.htmlhttps://github.com/expressjs/cookie-parserhttps://github.com/expressjs/cookie-session","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"cookie","slug":"cookie","permalink":"http://blog.langpz.com/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://blog.langpz.com/tags/session/"}]},{"title":"javascript数据类型转换","slug":"javascript数据类型转换","date":"2018-05-05T17:14:25.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"javascript数据类型转换.html","link":"","permalink":"http://blog.langpz.com/javascript数据类型转换.html","excerpt":"javascript数据类型转换在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。","text":"javascript数据类型转换在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。 默认是false的五个值1null undefined NaN 0 &apos;&apos; 记住只有这五个值是假的剩下的全部是真的。 转换规则 如果是一个值判断是否是真假，除了默认是false的五个值剩下的全部是true。 如果是两个值比较是否相等，遵循如下规则。 val1 == val2 如果两个值可能不是同一数据类型，如果是==比较的话，会默认进行数据转换。 2.1 object == object，比较永远不相等。 2.2 object == string 先将对象转换成字符串（调用toString方法），然后再比较。[] 转换成字符串 &quot;&quot; {} 转换成字符串 &quot;[object Object]&quot; 2.3 object == boolean 先将对象转换成字符串（toString），再把字符串转换成数字（Number）、布尔值转换成数字（true 转换成 1 false 换成成 0）然后让两个数字进行比较。Number(&quot;&quot;) 会输出 0 2.4 object == number 先将对象转换成字符串（toString），再把字符串转换成数字（Number），再进行比较。 2.5 number == boolean 布尔值转换成数字，然后再比较。 2.6 number == string 字符串转换成数字，然后再比较。 2.7 string == boolean 都转换成数字，，然后再比较。 2.8 null == undefined 结果是true。 2.9 null 或者 undefined 比较另外的所有值，结果都是false，不相等。 例如： [] == false 返回 true 2.3规则。 [] == [] 返回 false 2.1规则。 2 == true 返回 false 2.5规则。=== 三个等号还会比较数据类型。这些规则背下来，就能完美的应付这样的面试题了，加油！","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"数据类型转换","slug":"数据类型转换","permalink":"http://blog.langpz.com/tags/数据类型转换/"},{"name":"面试题","slug":"面试题","permalink":"http://blog.langpz.com/tags/面试题/"}]},{"title":"Git生成SSH公钥","slug":"Git生成SSH公钥","date":"2018-05-05T16:40:31.000Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"Git生成SSH公钥.html","link":"","permalink":"http://blog.langpz.com/Git生成SSH公钥.html","excerpt":"Git生成SSH公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。","text":"Git生成SSH公钥大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。 查看公钥是否生成过12cd ~/.sshls # 在Git bash下执行 或者 C:\\Users\\Administrator.ssh 访问这个目录。看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。如果有公钥直接打开 id_rsa.pub 文件添加到GitHub和coding的SSH公钥里面，建议coding有效期选永久。 生成公钥执行下面的命令。1ssh-keygen 它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。直接回车就行。然后去C:\\Users\\Administrator.ssh目录 找到id_rsa.pub 文件就是生成好的公钥，添加到GitHub和coding。公钥的大概样子，全部复制。123456ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local 测试公钥是否添加成功测试GitHub。1ssh git@github.com 现在就添加成功了。 测试Coding1ssh -T git@git.coding.net 参考https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"},{"name":"SSH公钥","slug":"SSH公钥","permalink":"http://blog.langpz.com/tags/SSH公钥/"}]},{"title":"Express文件上传","slug":"Express文件上传","date":"2018-05-04T15:58:58.000Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"Express文件上传.html","link":"","permalink":"http://blog.langpz.com/Express文件上传.html","excerpt":"Express文件上传在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。","text":"Express文件上传在后台项目中会经常碰见文件上传这个需求，例如用户上传一张头像等。。。今天就用Multer这个中间件来解决文件上传。 安装Multer第一步先安装Multer到你的项目里。1npm install --save multer 创建一个form表单这里就不用ajax去上传了。12345678910111213141516// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; form表单enctype属性 值 说明 application/x-www-form-urlencoded 在发送前编码所有字符（默认） multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。 引用配置multer123456789101112131415161718192021222324252627282930// app.jsconst express = require(&apos;express&apos;);const multer = require(&apos;multer&apos;);const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);const uploda = multer(&#123; dest: &apos;./uploads/&apos; // 服务接收文件的路径&#125;);let app = express();app.use(uploda.any()); // multer放到express中间件里app.post(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.files); // req.files接收到的文件信息一个数组 // 添加后缀名，只支持一个文件上加后缀名，多文件改成递归 let newName = req.files[0].path + path.extname(req.files[0].originalname); console.log(newName, req.files[0].path); fs.rename(req.files[0].path, newName, (err) =&gt; &#123; if(err)&#123; console.log(err); res.sendStatus(500).send(&apos;error&apos;); &#125;else&#123; res.send(&apos;OK，上传成功。&apos;); &#125; &#125;);&#125;);app.listen(8000); 在cmd执行 node app.js 打开index.html 选择文件上传，服务端就可以成功接收文件了。multer 还有一些别的方法和参数，可自行去github查看。 参考https://github.com/expressjs/multer","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"},{"name":"文件上传","slug":"文件上传","permalink":"http://blog.langpz.com/tags/文件上传/"}]},{"title":"javascript数组去重(ES6版)","slug":"javascript数组去重-ES6版","date":"2018-05-02T16:49:44.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"javascript数组去重-ES6版.html","link":"","permalink":"http://blog.langpz.com/javascript数组去重-ES6版.html","excerpt":"javascript数组去重(ES6版)之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。今天就利用 Set 来去重。","text":"javascript数组去重(ES6版)之前讲了如何利用循环和json对象去重，但是有BUG，如果是一个是字符串一个是数字就没办法区分了。今天就利用 Set 来去重。 123var arr = [1,2,3,4,5,&apos;1&apos;,&apos;2&apos;,3,3,&apos;1&apos;];arr = Array.from(new Set(arr));console.log(arr); Array.from() 方法从一个类似数组或可迭代对象中创建一个新的数组实例。 jsBin 地址","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://blog.langpz.com/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://blog.langpz.com/tags/数组/"},{"name":"ES6","slug":"ES6","permalink":"http://blog.langpz.com/tags/ES6/"}]},{"title":"css实现元素垂直水平居中-包括未知宽高的元素","slug":"css实现元素垂直居中-包括未知宽高的元素","date":"2018-04-28T13:14:04.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"css实现元素垂直居中-包括未知宽高的元素.html","link":"","permalink":"http://blog.langpz.com/css实现元素垂直居中-包括未知宽高的元素.html","excerpt":"css实现元素垂直水平居中-包括未知宽高的元素这个一道很经典的面试题，做项目中也常会出现这样的需求。现在我就用几种比较常用的方法。兼容性也列出来。","text":"css实现元素垂直水平居中-包括未知宽高的元素这个一道很经典的面试题，做项目中也常会出现这样的需求。现在我就用几种比较常用的方法。兼容性也列出来。 第一种已知宽高（定位加负边距解决）兼容到IE6123456789position: absolute;z-index: 8;left: 50%;top: 50%;width: 200px;height: 200px;margin-left: -100px;margin-top: -100px;background: red; demo地址 JSBin 第二种未知宽高 (定位加margin解决) 兼容到IE8 移动端推荐使用12345678910position: absolute;z-index: 8;left: 0;top: 0;bottom: 0;right: 0;width: 200px;height: 200px;margin: auto;background: red; 如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin 第三种未知宽高 (定位加transform解决) 兼容到IE9 移动端推荐使用12345678position: absolute;z-index: 8;left: 50%;top: 50%;width: 200px;height: 200px;transform: translate(-50%, -50%);background: red; 如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin 第四种未知宽高 (弹性盒子模型解决) 兼容到IE101234display: flex;display: -webkit-flex;align-items:center;justify-content: center; 如果改变宽度和高度还是垂直水平居中的。demo地址 JSBin 第五种未知宽高 (table特性解决的) 兼容到IE6 PC端推荐使用12345678910111213141516171819202122232425#box&#123; width: 100px; height:100px; text-align:center; font-size:0; background: red&#125;#box:after,#box span&#123; display:inline-block; *display:inline; *zoom:1; width:0; height:100%; vertical-align:middle;&#125;#box:after&#123; content:&apos;&apos;;&#125;#box p&#123; display:inline-block; *display:inline; *zoom:1; vertical-align:middle; font-size:16px;&#125; demo地址 JSBin 参考http://demo.doyoe.com/css/alignment/","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.langpz.com/tags/css/"}]},{"title":"EJS模板引擎","slug":"ejs模板引擎","date":"2018-04-27T13:36:44.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"ejs模板引擎.html","link":"","permalink":"http://blog.langpz.com/ejs模板引擎.html","excerpt":"EJS模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。","text":"EJS模板引擎模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。Express默认的模板引擎是Jade，为什么要选择EJS呢，因为它非常简单而且不破坏原有HTML代码结构。只需要用JavaScript编写你想要的HTML。 安装EJS1npm install ejs Express设置EJS模板12app.set(&apos;view engine&apos;, &apos;ejs&apos;); # view engine, 模板引擎app.set(&apos;views&apos;, &apos;./views&apos;); # views, 放模板文件的目录 将值输出到模板（HTML转义）12345// index.ejs&lt;%= arr %&gt;// Noderes.render(&apos;index&apos;, &#123;arr: [1,2,3,4]&#125;); 判断123&lt;% if (user) &#123; %&gt; &lt;p&gt; &lt;%= user %&gt; &lt;/p&gt;&lt;% &#125; %&gt; 循环123&lt;% for (var i = 0; i &lt; arr.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= arr[i] %&gt;&lt;/li&gt;&lt;% &#125; %&gt; include（不转义）1&lt;%- include(&apos;./common/header.ejs&apos;) %&gt; EJS标签 &lt;% ‘脚本’ 标签，用于流程控制，无输出。 &lt;%_ 删除其前面的空格符 &lt;%= 输出数据到模板（输出是转义 HTML 标签） &lt;%- 输出非转义的数据到模板 &lt;%# 注释标签，不执行、不输出内容 &lt;%% 输出字符串 ‘&lt;%’ %&gt; 一般结束标签 -%&gt; 删除紧随其后的换行符 _%&gt; 将结束标签后面的空格符删除","categories":[],"tags":[{"name":"EJS","slug":"EJS","permalink":"http://blog.langpz.com/tags/EJS/"}]},{"title":"Express中间件body-parser简单实现","slug":"Express中间件body-parser简单实现","date":"2018-04-18T11:49:16.000Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"Express中间件body-parser简单实现.html","link":"","permalink":"http://blog.langpz.com/Express中间件body-parser简单实现.html","excerpt":"Express中间件body-parser简单实现之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。","text":"Express中间件body-parser简单实现之前文章写了怎么用body-parser中间件处理post请求，今天就大概实现下body-parser中urlencoded 这个方法。首先通过命令提示输入 mkdir lib &amp;&amp; cd lib。再输入touch body-parser.js。把下面的代码在body-parser.js 敲一遍。1234567891011121314151617// lib/body-parser.jsconst querystring = require(&apos;querystring&apos;);module.exports.urlencoded = function (req, res, next) &#123; let chunks = []; req.on(&apos;data&apos;, data =&gt; &#123; chunks.push(data); &#125;); req.on(&apos;end&apos;, () =&gt; &#123; // 合并Buffer。 let buf = Buffer.concat(chunks).toString(); // 把querystring解析过的json 放到 req.body上。 req.body = querystring.parse(buf); next(); &#125;);&#125; 下面是主程序代码。1234567891011121314// app.jsconst express = require(&apos;express&apos;);const bodyParser = require(&apos;./lib/body-parser&apos;);let app = express();app.use(bodyParser.urlencoded);app.post(&apos;/&apos;, (req, res) =&gt; &#123; res.send(req.body);&#125;);app.listen(8000); 现在就完成和body-parser中间件类似的功能了，req.body上面有请求过来的post数据。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"Express处理数据请求","slug":"Express处理数据请求","date":"2018-04-02T17:28:39.000Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"Express处理数据请求.html","link":"","permalink":"http://blog.langpz.com/Express处理数据请求.html","excerpt":"Express处理数据请求之前文章里面介绍了如何用原生Node处理数据请求。现在通过Express框架处理post和get请求。","text":"Express处理数据请求之前文章里面介绍了如何用原生Node处理数据请求。现在通过Express框架处理post和get请求。 处理get请求这个比较简单(不需要使用中间件)直接req.query就能获取到。1234567891011// 服务端代码const express = require(&apos;express&apos;);let app = express();app.get(&apos;/&apos;, (req, res) =&gt; &#123; console.log(req.query);&#125;);app.listen(8000); 1234567891011121314151617// 客户端代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。就可以获取到一个json对象如 { user: ‘123’, pass: ‘abc’ } 方便操作。 处理post请求处理post请求需要用到body-parser这个中间件。这个中间件可以解析JSON、Raw、文本、URL-encoded格式的请求体。先安装中间件1npm install body-parser 在项目中引用body-parser中间件。123456789101112131415// 服务端代码const express = require(&apos;express&apos;);const bodyParser = require(&apos;body-parser&apos;);let app = express();// 引用body-parser中间件app.use(bodyParser.urlencoded());app.post(&apos;/&apos;, (req, res) =&gt; &#123; // req.body post 提交过来的数据 console.log(req.body);&#125;);app.listen(8000); 1234567891011121314151617// 客户端代码&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 用命令提示行运行服务器，打开刚才写好的网页输入内容提交表单。就可以获取到一个json对象如 { user: ‘lanpangzhi’, pass: ‘123456’ } 方便操作。这样我们就通过Express获取到get和post提交过来的数据了。 urlencoded() 方法配置参数 (options) extended 设置为false时，会使用querystring库解析URL编码的数据；当设置为true时，会使用qs库解析URL编码的数据。后没有指定编码时，使用此编码。默认为true。但使用默认已被弃用。 请研究qs和querystring之间的差异并选择适当的设置。 inflate 设置为true时，deflate压缩数据会被解压缩；设置为true时，deflate压缩数据会被拒绝。默认为true。 limit 设置最大请求头大小， 如果这是一个数字，那么该值指定字节数; 如果它是一个字符串，则将该值传递给字节库解析。默认为100kb。 parameterLimit 用于设置URL编码值的最大参数数量， 如果请求包含的参数多于此值，那么413将返回给客户端。默认为1000。 type 用于设置为指定MIME类型的数据使用当前解析中间件。这个选项可以是一个函数或是字符串，当是字符串是会使用type-is来查找MIMI类型；当为函数是，中间件会通过fn(req)来获取实际值。默认为application/octet-stream。 verify 这个选项仅在verify(req, res, buf, encoding)时受支持。 body-parser里面还有另外几个方法，可以自行去github看下。 参考[https://github.com/expressjs/body-parser]","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"express简单入坑","slug":"express简单入坑","date":"2018-03-19T13:38:00.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"express简单入坑.html","link":"","permalink":"http://blog.langpz.com/express简单入坑.html","excerpt":"express简单入坑Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。","text":"express简单入坑Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 安装12npm init npm install express --save 创建第一个应用12345678910// app.jsconst express = require(&apos;express&apos;);let app = express();app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.send(&apos;express&apos;);&#125;);app.listen(8000); 在命令行执行 node app.js 浏览器输入 http://localhost:8000/就可以访问了。 路由控制app.get(path, (request, response) =&gt; {})根据path处理客户端发过来的GET请求。第一个参数：path请求的路径。第二个参数：回调函数，request(请求),response(响应)123456app.get(&apos;/&apos;,(req,res) =&gt; &#123; res.send(&apos;home&apos;);&#125;);app.get(&apos;/hello&apos;,(req,res) =&gt; &#123; res.send(&apos;hello&apos;);&#125;); app.post(path, (request, response) =&gt; {})根据path处理客户端发过来的POST请求。参数和app.get()方法一样。123456app.post(&apos;/&apos;, (req, res) =&gt; &#123; res.send(&apos;home&apos;);&#125;);app.post(&apos;/hello&apos;, (req, res) =&gt; &#123; res.send(&apos;hello&apos;);&#125;); app.all(path, (request, response) =&gt; {})根据path处理客户端发过来的所有http(GET,POST,PUT,DELETE,HEAD)请求。参数和app.get()方法一样。 res.send() 发送各种类型的响应。res.download() 提示下载文件。res.redirect() 重定向请求。res.sendStatus() 设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。 静态文件Express 内置的 express.static 可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。只需要把文件目录作为参数传给express.static，之后就可以访问到静态文件。1app.use(express.static(&apos;./public&apos;)) 注： 所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中。 中间件Express应用就是在调用各种中间件完成功能的，如cookie解析、文件上传、静态文件等。中间件（Middleware） 是一个函数。它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。12345678910111213app.use((req, res, next) =&gt; &#123; console.log(&apos;aaa&apos;); next();&#125;)app.use((req, res, next) =&gt; &#123; console.log(&apos;bbb&apos;); next()&#125;)app.use((req, res, next) =&gt; &#123; console.log(&apos;ccc&apos;);&#125;) 可以看到next 的作用，把控制器交给下一个中间件。可以利用中间件特性来处理登陆用户。 检查数据是否合法。 检查数据是否存在。 检查数据密码是否正确。1234567891011121314151617181920212223app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123; if(合法)&#123; next() &#125;else&#123; res.send(&apos;用户名不合法&apos;) &#125;&#125;)app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123; if(存在)&#123; next() &#125;else&#123; res.send(&apos;用户名不存在&apos;) &#125;&#125;)app.get(&apos;/login&apos;, (req, res, next) =&gt; &#123; if(密码正确)&#123; res.send(&apos;登陆成功&apos;) &#125;else&#123; res.send(&apos;密码不正确&apos;) &#125;&#125;) 中间件的大概用法就是这样。 模板引擎先安装ejs模板npm install ejs -S12app.set(&apos;view engine&apos;, &apos;ejs&apos;); # view engine, 模板引擎app.set(&apos;views&apos;, &apos;./views&apos;); # views, 放模板文件的目录 1234567891011121314// index.jsconst express = require(&apos;express&apos;);const ejs = require(&apos;ejs&apos;);let app = express();app.set(&apos;view engine&apos;, &apos;ejs&apos;);app.set(&apos;views&apos;, &apos;./views&apos;);app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.render(&apos;index&apos;,&#123;title: &apos;hello&apos;&#125;);&#125;);app.listen(8000); 12345678910111213// index.ejs&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;%= title %&gt;&lt;/body&gt;&lt;/html&gt; 在命令行里执行node index.js，就可以看到模板了。","categories":[],"tags":[{"name":"Express","slug":"Express","permalink":"http://blog.langpz.com/tags/Express/"}]},{"title":"node处理前台get请求","slug":"node处理前台get请求","date":"2018-03-02T10:07:32.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"node处理前台get请求.html","link":"","permalink":"http://blog.langpz.com/node处理前台get请求.html","excerpt":"node.js处理前台get请求下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。","text":"node.js处理前台get请求下面代码实现了用node.js接收前台发送的get请求。用到了http模块和url模块。 服务端代码123456789101112const http = require(&apos;http&apos;);const url = require(&apos;url&apos;);let app = http.createServer((req, res) =&gt; &#123; let getUrl = url.parse(req.url, true); if (getUrl.pathname === &apos;/getUser&apos;)&#123; console.log(url.parse(req.url, true).query); res.end(url.parse(req.url, true).query.user); &#125;&#125;);app.listen(8000); 先搭一个服务器监听8000端口，再把请求的链接用URL模块解析成对象，判断请求路径，返回user。 客户端代码1234567891011121314151617// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000/getUser&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在命令行执行 node http.js。打开index.html 输入数据，点击提交按钮。node输出 { user: ‘123’, pass: ‘abc’ } 123和abc 就是你输入的数据。前台页面会显示你输入的user。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"url模块","slug":"url模块","date":"2018-03-01T16:03:22.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"url模块.html","link":"","permalink":"http://blog.langpz.com/url模块.html","excerpt":"url模块url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。模块只有三个方法，用起来也简单。","text":"url模块url模块，用于将url字符串解析为对象或将对象格式化为url字符串，用来处理get请求非常方便。模块只有三个方法，用起来也简单。 url结构说明网址：http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash 从node.js 中文网拿的图。 url.parse(urlString[, parseQueryString[, slashesDenoteHost]])123let url = require(&apos;url&apos;);console.log(url.parse(&apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos;)) 把url字符串解析成url对象。输出:12345678910111213&#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;langpz.com:80&apos;, port: &apos;80&apos;, hostname: &apos;langpz.com&apos;, hash: &apos;#top&apos;, search: &apos;?callback=fn&apos;, query: &apos;callback=fn&apos;, pathname: &apos;/aaa/ccc/ddd&apos;, path: &apos;/aaa/ccc/ddd?callback=fn&apos;, href: &apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos; &#125; protocol: 请求协议。 slashes: slashes 属性是一个 boolean，如果 协议 中的冒号后面跟着两个 ASCII 斜杠字符（/），则值为 true。 auth： URL的用户名与密码部分。 host: URL的主机部分包括端口号。 port：主机的端口号。 hostname：主机名部分。 hash： 锚点部分。 search： 整个查询字符串部分，包括前面的?号 query: 查询字符串部分，不包括前面的?号 pathname：URL 的整个路径部分。 path： pathname 与 search 组成部分的串接。 href： 解析后的完整的 URL 字符串，protocol 和 host 都会被转换为小写的。 第二个参数是布尔值，如果是 true，query值是一个对象。 默认为 false。第三个参数是布尔值，如果是 true，则 // 之后至下一个 / 之前的字符串会被解析作为 host。 例如，//foo/bar 会被解析为 {host: ‘foo’, pathname: ‘/bar’} 而不是 {pathname: ‘//foo/bar’}。 默认为 false。 url.format(urlObject)12345678910111213141516let url = require(&apos;url&apos;);console.log(url.format(&#123; protocol: &apos;http:&apos;, slashes: true, auth: &apos;user:pass&apos;, host: &apos;langpz.com:80&apos;, port: &apos;80&apos;, hostname: &apos;langpz.com&apos;, hash: &apos;#top&apos;, search: &apos;?callback=fn&apos;, query: &apos;callback=fn&apos;, pathname: &apos;/aaa/ccc/ddd&apos;, path: &apos;/aaa/ccc/ddd?callback=fn&apos;, href: &apos;http://user:pass@langpz.com:80/aaa/ccc/ddd?callback=fn#top&apos;&#125;)); url.parse()的反向操作，把url对象解析成url字符串 url.resolve(from, to)12345let url = require(&apos;url&apos;);console.log(url.resolve(&apos;/one/two/three&apos;,&apos;four&apos;)) # 输出 /one/two/fourconsole.log(url.resolve(&apos;http://blog.langpz.com/&apos;, &apos;aaa&apos;)) # 输出 http://blog.langpz.com/aaaconsole.log(url.resolve(&apos;http://blog.langpz.com/aaa&apos;, &apos;bbb&apos;)) # 输出 http://blog.langpz.com/bbb 把最后一个/没有内容后面追加to参数，有内容则替换。 参考http://nodejs.cn/api/url.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"node处理前台post请求","slug":"node处理前台post请求","date":"2018-03-01T10:29:37.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"node处理前台post请求.html","link":"","permalink":"http://blog.langpz.com/node处理前台post请求.html","excerpt":"node.js处理前台post请求下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。","text":"node.js处理前台post请求下面代码实现了用node.js接收前台发送的post请求。用到了http模块和querystring模块。 服务端代码123456789101112131415161718// http.jslet http = require(&apos;http&apos;);let querystring = require(&apos;querystring&apos;);let app = http.createServer((req, res) =&gt; &#123; let str = &apos;&apos;; if (req.url === &apos;/post&apos;)&#123; req.on(&apos;data&apos;, (data) =&gt; &#123; str += data; &#125;); req.on(&apos;end&apos;, () =&gt; &#123; console.log(querystring.parse(str)); &#125;); &#125;&#125;);app.listen(8000) 先搭一个服务器监听8000端口，判断请求路径，再绑定data事件接收客户端发过来的post请求，接受用querystring模块处理接收的数据。 客户端代码1234567891011121314151617// index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=&quot;http://localhost:8000/post&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在命令行执行 node http.js。打开index.html 输入数据，点击提交按钮。node输出 { user: ‘123’, pass: ‘abc’ } 123和abc 就是你输入的数据。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"stream模块","slug":"stream模块","date":"2018-02-27T13:27:30.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"stream模块.html","link":"","permalink":"http://blog.langpz.com/stream模块.html","excerpt":"stream (流)流（stream）在 Node.js 中是处理流数据的抽象接口。stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。","text":"stream (流)流（stream）在 Node.js 中是处理流数据的抽象接口。stream 模块提供了基础的 API 。使用这些 API 可以很容易地来构建实现流接口的对象。Node.js 提供了多种流对象。 例如， HTTP 请求 和 process.stdout 就都是流的实例。流可以是可读的、可写的，或是可读写的。所有的流都是 EventEmitter 的实例。 为什么使用stream我们之前读文件用的是readFile()把整个文件读入到内存，如果文件小还可以，假如你读取的文件有几个G就会把内存撑爆，这个时候就需要stream(流)了，收到一块数据，就读取一块。这样占用内存就会小很多。 流的类型Node.js 中有四种基本的流类型：Readable - 可读的流Writable - 可写的流Duplex - 可读写的流Transform - 在读写过程中可以修改和变换数据的 Duplex 流 可读流的常用事件data 当有数据可读时触发end 没有更多的数据可读时触发。error 在接收和写入过程中发生错误时触发。 可读流12345678910111213let fs = require(&apos;fs&apos;);let rs = fs.createReadStream(&apos;./hello.txt&apos;,&#123; encoding: &apos;utf8&apos;&#125;);rs.on(&apos;data&apos;, data =&gt; &#123; console.log(&apos;读取中--------&apos; + data +&apos;--------&apos;) # 如果文件过大会分几次输出数据。&#125;);rs.on(&apos;end&apos;, () =&gt; &#123; console.log(&apos;读取完毕&apos;); # data读取完触发 end 事件。&#125;) 第一个参数是路径。第二个参数是可配置对象。 flags: 读取模式默认为r（只读） encoding: 设置编码默认null mode: 设置文件模式默认0o666 start: 用整数表示文件开始读取字节数的索引位置 end: 用整数表示文件结束读取字节数的索引位置 highWaterMark: 最高水位线，停止从底层资源读取前，内部缓存区最多存放的字节数。默认64kb 暂停流对象触发 ‘data’ 事件1rs.pause() 重新流对象触发 ‘data’ 事件1rs.resume() 可写流12345678910let fs = require(&apos;fs&apos;);let stream = fs.createWriteStream(&apos;./1.txt&apos;)stream.write(&apos;lan&apos;) # 写入数据stream.write(&apos;pang&apos;) # 写入数据stream.end(&apos;zi&apos;) # 写入数据stream.on(&apos;finish&apos;, function() &#123; console.log(&quot;写入完成。&quot;);&#125;); 第一个参数是路径。第二个参数是可配置对象。 flags: 读取模式默认为w encoding: 设置编码默认utf8 mode: 设置文件模式默认0o666 start: 用整数表示文件开始写入字节数的索引位置 highWaterMark: 最高水位线，内部缓存区最多存放的字节数。默认16kb stream.write(chunk[, encoding][, callback])第一个参数写入的数据。第二个参数设置编码。第三个参数回调函数。返回一个boolean值。写入数据的时候内部缓冲区的大小小于创建流时设定的 highWaterMark 阈值，函数将返回 true 。如果返回值为 false ，应该停止向流中写入数据，直到 ‘drain’ 事件被触发。 123456789101112131415161718192021let fs = require(&apos;fs&apos;);let stream = fs.createWriteStream(&apos;./1.txt&apos;,&#123; highWaterMark: 10&#125;);let i = 0;let max = 100;let write = () =&gt; &#123; let flag = true; while (i &lt; max &amp;&amp; flag)&#123; console.log(&apos;写入&apos; + i); i++; flag = stream.write(String(i)); &#125;&#125;write();stream.on(&apos;drain&apos;,() =&gt; &#123; console.log(&apos;继续写入&apos;+ i); write();&#125;); drain事件如果调用 stream.write(chunk) 方法返回 false，’drain’ 事件会在适合恢复写入数据到流的时候触发。 stream.end(chunk[, encoding][, callback])第一个参数写入的数据。第二个参数设置编码。第三个参数回调函数。调用 writable.end() 方法表明接下来没有数据要被写入 Writable。通过传入可选的 chunk 和 encoding 参数，可以在关闭流之前再写入一段数据。如果传入了可选的 callback 函数，它将作为 ‘finish’ 事件的回调函数。在调用了 stream.end() 方法之后，再调用 stream.write() 方法将会导致错误。 pipe()12345let fs = require(&apos;fs&apos;);let rs = fs.createReadStream(&apos;./1.txt&apos;);let ws = fs.createWriteStream(&apos;./2.txt&apos;);rs.pipe(ws) readable.pipe(destination[, options])readable 可读流对象destination 可写流对象readable.pipe() 绑定一个 Writable 到 readable 上， 将可写流自动切换到 flowing 模式并将所有数据传给绑定的 Writable。数据流将被自动管理。这样，即使是可读流较快，目标可写流也不会超负荷（overwhelmed）。pipe 方法是使用流最简单的方式。通常的建议是要么使用 pipe 方法、要么使用事件来读取流，要避免混合使用两者。一般情况下使用 pipe 方法时你就不必再使用事件了。但如果你想以一种更加自定义的方式读取流，就要用到事件了。 参考http://nodejs.cn/api/stream.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"path模块","slug":"path模块","date":"2018-02-26T11:17:42.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"path模块.html","link":"","permalink":"http://blog.langpz.com/path模块.html","excerpt":"path模块path模块是Node.js提供用于处理文件与目录的路径。","text":"path模块path模块是Node.js提供用于处理文件与目录的路径。 连接路径123let path = require(&apos;path&apos;);console.log(path.join(__dirname,&apos;lan&apos;,&apos;pang&apos;,&apos;zi&apos;)) # 输出c:\\Users\\windows\\Desktop\\新建文件夹\\lan\\pang\\zi 为什么要使用这个方法，因为Windows和liunx系统路径分隔符不一样，liunx系统是”/“，Windows系统是”\\”，path.join()会正确使用当前系统的路径分隔符。 获取路径扩展名123let path = require(&apos;path&apos;);console.log(path.extname(__filename)) # 输出 .js 从 path 的最后一部分中的最后一个 . 字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名的第一个字符是 .，则返回一个空字符串。1234console.log(path.extname(&apos;.lanpangzhi&apos;)) # 输出空字符串console.log(path.extname(&apos;lanpangzhi.github.exe&apos;)) # 输出 .execonsole.log(path.extname(&apos;lanpangzhi.&apos;)) # 输出 .console.log(path.extname(&apos;lanpangzhi&apos;)) # 输出空字符串 获取绝对路径123let path = require(&apos;path&apos;);console.log(path.resolve(&apos;lan/pang&apos;,&apos;zi&apos;)) # 输出 c:\\Users\\windows\\Desktop\\新建文件夹\\lan\\pang\\zi 路径的序列是从右往左被处理的。如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录。如果不传参数会得到当前所在的目录 判断是否是绝对路径1234let path = require(&apos;path&apos;);console.log(path.isAbsolute(&apos;/lanpangzhi&apos;)) # 输出 trueconsole.log(path.isAbsolute(&apos;lanpangzhi/&apos;)) # 输出 false 如果 path 不是一个字符串，则抛出 TypeError。 获取路径中的文件名1234let path = require(&apos;path&apos;);console.log(path.basename(__filename)) # 输出 http.jsconsole.log(path.basename(__filename,&apos;.js&apos;)) # 输出 http 第一个参数是路径。第二个参数是文件扩展名，如果加上只返回文件名。 path.sep 文件路径分隔符path.delimiter 环境变量路径分隔符参考http://nodejs.cn/api/path.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"fs模块","slug":"fs模块","date":"2018-02-22T14:32:19.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"fs模块.html","link":"","permalink":"http://blog.langpz.com/fs模块.html","excerpt":"fs模块fs模块是Node.js提供来操作本地文件（读、写、复制、删除…）等功能的模块。所有的方法都有异步和同步的形式。异步方法最后一个参数都是一个回调函数，回调函数的第一个参数是异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。当使用同步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。","text":"fs模块fs模块是Node.js提供来操作本地文件（读、写、复制、删除…）等功能的模块。所有的方法都有异步和同步的形式。异步方法最后一个参数都是一个回调函数，回调函数的第一个参数是异常。 如果操作成功完成，则第一个参数会是 null 或 undefined。当使用同步方法时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让异常向上冒泡。 读取文件同步方法 readFileSync()12345678let fs = require(&apos;fs&apos;);try&#123; let buf = fs.readFileSync(&apos;./hello.txt&apos;, &#123; encoding: &apos;utf-8&apos; &#125;); console.log(buf); # 输出: 入坑了..&#125;catch(err)&#123; console.log(&apos;读取失败了: &apos; + err.message)&#125; readFileSync方法的第一个参数是文件路径可以是（string|Buffer|URL|integer）类型，第二个参数可以是一个表示配置的对象。默认的配置对象是{ encoding: null, flag: ‘r’ }，encoding：文件编码默认为null，flag：读取模式默认为r（只读）。如果第二个参数不指定编码（encoding），readFileSync方法返回原始的 buffer。 异步方法 readFile()1234567let fs = require(&apos;fs&apos;);fs.readFile(&apos;./hello.txt&apos;, &#123; encoding: &apos;utf-8&apos; &#125;, (err,data) =&gt; &#123; if (err)&#123; throw err; &#125; console.log(data); # 输出: 入坑了..&#125;); 和readFileSync方法参数一样，只多了一个回调函数。回调有两个参数 (err, data)，其中 data 是文件的内容。 写入文件同步方法 writeFileSync()123let fs = require(&apos;fs&apos;);fs.writeFileSync(&apos;./1.txt&apos;,&apos;node入坑指南...&apos;,&#123;encoding: &apos;utf8&apos;&#125;) 第一个参数是路径第二的参数是写入的数据第三个参数是一个可配置的对象{encoding：utf8, mode: 0o666, flag: ‘w’} encoding: 文件编码默认为utf8 mode： 设置文件模式(权限)，文件创建默认权限为 0o666(可读，可写)。 flag： 文件打开模式默认为w(写入) 如果 options 是一个字符串，则它指定了字符编码。例如：1fs.writeFileSync(&apos;./1.txt&apos;, &apos;111...&apos;, &apos;utf8&apos;) 异步方法 writeFile()12345678let fs = require(&apos;fs&apos;);fs.writeFile(&apos;./2.txt&apos;,&apos;蓝胖纸&apos;,(err) =&gt; &#123; if(err)&#123; throw err; &#125; console.log(&apos;写入成功&apos;);&#125;) 异步地写入数据到文件，如果文件已经存在，则替代文件。 data 可以是一个字符串或一个 buffer。如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’。和writeFileSync方法参数一样，只多了一个回调函数。 创建目录同步方法 mkdirSync()1fs.mkdirSync(&apos;./hello&apos;,0o777); 在当前目录下面创建一个hello的文件夹。第一个参数是路径。第二个参数是设置文件模式(权限)，默认为0o777。 异步方法 mkdir()123fs.mkdir(&apos;./lanpangzhi&apos;, 0o777, function (err) &#123; if (err) throw err;&#125;); 和mkdirSync方法参数一样，只多了一个回调函数。注： 所有的异步方法最后一个参数都是回调函数，回调函数的第一个参数都是异常。 读取目录同步方法 readdirSync()12let a = fs.readdirSync(process.cwd())console.log(a) 输出当前工作目录下的文件数组列表。第一个参数是路径。第二个参数是设置编码。 异步方法 readdir()123456fs.readdir(process.cwd(),(err, files) =&gt; &#123; if (err)&#123; throw err; &#125; console.log(files)&#125;) 和readdirSync方法参数一样，只多了一个回调函数。回调函数有两个参数，第二个参数是文件数组列表。 查看文件信息同步方法 statSync()12let stats = fs.statSync(&apos;./a.js&apos;);console.log(stats) 接受一个路径参数，返回一个 fs.Stats 实例。 fs.Stats 实例的方法 方法 描述 stats.isFile() 如果是文件返回 true，否则返回 false。 stats.isDirectory() 如果是目录返回 true，否则返回 false。 stats.isBlockDevice() 如果是块设备返回 true，否则返回 false。 stats.isCharacterDevice() 如果是字符设备返回 true，否则返回 false。 stats.isSymbolicLink() 如果是软链接返回 true，否则返回 false。 stats.isFIFO() 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。 stats.isSocket() 如果是 Socket 返回 true，否则返回 false。 Stat 时间值 属性 描述 atime “访问时间” - 文件数据最近被访问的时间。 mtime “修改时间” - 文件数据最近被修改的时间。 ctime “变化时间” - 文件状态最近更改的时间。 birthtime “创建时间” - 文件创建的时间。 异步方法 stat()12345678let fs = require(&apos;fs&apos;);fs.stat(&apos;./hello&apos;, (err, stats)=&gt;&#123; if(err)&#123; throw err; &#125; console.log(stats);&#125;); 和statSync方法参数一样，只多了一个回调函数。回调函数有两个参数，第二个参数是fs.Stats实例。 删除文件同步方法 unlinkSync()123let fs = require(&apos;fs&apos;);fs.unlinkSync(&apos;./1.txt&apos;); 删除当前目录下的1.txt文件，返回undefined。第一个参数是路径。 异步方法 unlink()1234567let fs = require(&apos;fs&apos;);fs.unlink(&apos;./2.txt&apos;, (err) =&gt; &#123; if(err)&#123; console.log(err) &#125;&#125;) 和unlinkSync方法参数一样。 参考http://nodejs.cn/api/fs.htmlhttp://www.runoob.com/nodejs/nodejs-fs.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"querystring模块","slug":"querystring模块","date":"2018-02-09T13:10:53.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"querystring模块.html","link":"","permalink":"http://blog.langpz.com/querystring模块.html","excerpt":"querystring模块querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。处理get请求参数的时候用的比较多。","text":"querystring模块querystring 模块提供了一些实用函数，用于解析与格式化 URL 查询字符串。处理get请求参数的时候用的比较多。 把字符串转换成对象 querystring.parse(str[, sep[, eq[, options]]])12345678910111213141516171819202122232425262728let querystring = require(&apos;querystring&apos;);let query = querystring.parse(&apos;name=lanpangzhi&amp;age=18&apos;);console.log(query); # 输出&#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;// 添加第二个参数 seplet query2 = querystring.parse(&apos;name=lanpangzhi@age=18&apos;,&apos;@&apos;);console.log(query2); # 输出&#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;// sep: 第二个参数用于界定查询字符串中的键值对的子字符串。默认为 &apos;&amp;&apos;。// 添加第三个参数 eqlet query3 = querystring.parse(&apos;name|lanpangzhi@age|18&apos;,&apos;@&apos;,&apos;|&apos;);console.log(query3); // eq: 用于界定查询字符串中的键与值的子字符串。默认为 &apos;=&apos;。// sep eq 可以替换割分字符串的关键字，在某些特定的场景会用的。// 第四个参数用得比较少let query = querystring.parse(&apos;name|lanpangzhi@age|18@age2|20@age3|21@age4|555&apos;,&apos;@&apos;,&apos;|&apos;,&#123; decodeURIComponent: function test(str) &#123; return str+= &apos;1&apos; &#125;, maxKeys: 4&#125;);console.log(query); # 输出 &#123; name1: &apos;lanpangzhi1&apos;, age1: &apos;181&apos;, age21: &apos;201&apos;, age31: &apos;211&apos; &#125;// 第四个参数是一个对象， 里面有 decodeURIComponent 和 maxKeys 两个参数。// decodeURIComponent: 解码查询字符串的字符时使用的函数。默认为 querystring.unescape()。// maxKeys: 指定要解析的键的最大数量。默认为 1000。指定为 0 则不限制。// 我刚才指定是4 所以 age4 这个参数没输出。 把对象转换成字符串 querystring.stringify(obj[, sep[, eq[, options]]])1234567891011121314151617181920let querystring = require(&apos;querystring&apos;);let obj = &#123; name: &apos;lanpangzhi&apos;, baz: [&apos;qux&apos;, &apos;quux&apos;], age: &apos;18&apos; &#125;;let str = querystring.stringify(obj);console.log(str); # 输出 name=lanpangzhi&amp;baz=qux&amp;baz=quux&amp;age=18// 添加第二个参数 seplet obj = &#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;;let str = querystring.stringify(obj,&apos;@&apos;);console.log(str); # 输出 name=lanpangzhi@age=18// sep: 第二个参数用于界定查询字符串中的键值对的子字符串。默认为 &apos;&amp;&apos;。// 添加第三个参数 eqlet obj = &#123; name: &apos;lanpangzhi&apos;, age: &apos;18&apos; &#125;;let str = querystring.stringify(obj,&apos;@&apos;,&apos;|&apos;);console.log(str);// eq: 用于界定查询字符串中的键与值的子字符串。默认为 &apos;=&apos;。// 第四个参数 options 基本上用不到// encodeURIComponent &lt;Function&gt; : 把对象中的字符转换成查询字符串时使用的函数。默认为 querystring.escape()。 querystring.stringify 和 querystring.parse 功能正好是对应的， 基本上第四个参数用不到，第二和第三个参数只有在某些特定的场景才会使用，指定切割默写字符，或者输出某些字符。querystring 这个模块还有两个方法，但是基本上不会用到，更多可以去node中文网或者官网查看。新年快乐2018 参考http://nodejs.cn/api/querystring.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Buffer对象","slug":"Buffer对象","date":"2018-02-06T13:43:40.000Z","updated":"2018-06-21T08:05:23.861Z","comments":true,"path":"Buffer对象.html","link":"","permalink":"http://blog.langpz.com/Buffer对象.html","excerpt":"Buffer对象在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’)。","text":"Buffer对象在 ECMAScript 2015 (ES6) 引入 TypedArray 之前，JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。Buffer 类在 Node.js 中是一个全局变量，因此无需使用 require(‘buffer’)。 创建一个Buffer对象Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。 Buffer.from(array) 返回一个新建的包含所提供的字节数组的副本的 Buffer。 Buffer.from(arrayBuffer[, byteOffset [, length]]) 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。 Buffer.from(buffer) 返回一个新建的包含所提供的 Buffer 的内容的副本的 Buffer。 Buffer.from(string[, encoding]) 返回一个新建的包含所提供的字符串的副本的 Buffer。 Buffer.alloc(size[, fill[, encoding]]) 返回一个指定大小的被填满的 Buffer 实例。这个方法会明显地比 Buffer.allocUnsafe(size) 慢，但可确保新创建的 Buffer 实例绝不会包含旧的和潜在的敏感数据。 Buffer.allocUnsafe(size)与 Buffer.allocUnsafeSlow(size) 返回一个新建的指定 size 的 Buffer，但它的内容必须被初始化，可以使用 buf.fill(0) 或完全写满。123456789101112131415161718192021// 创建一个长度为 10、且用 0 填充的 Buffer。const buf1 = Buffer.alloc(10);// 创建一个长度为 10、且用 0x1 填充的 Buffer。 const buf2 = Buffer.alloc(10, 1);// 创建一个长度为 10、且未初始化的 Buffer。// 这个方法比调用 Buffer.alloc() 更快，// 但返回的 Buffer 实例可能包含旧数据，// 因此需要使用 fill() 或 write() 重写。const buf3 = Buffer.allocUnsafe(10);buf3.fill(0)// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。数组里一定是0-255的数，否则会不识别，返回00const buf4 = Buffer.from([1, 2, 3]);// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。const buf5 = Buffer.from(&apos;tést&apos;);// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。const buf6 = Buffer.from(&apos;tést&apos;, &apos;latin1&apos;); 在 Node.js v6 之前的版本中Buffer 实例是通过 new Buffer 构造函数创建的，因为 new Buffer() 的行为会根据所传入的第一个参数的值的数据类型而明显地改变，所以如果应用程序没有正确地校验传给 new Buffer() 的参数、或未能正确地初始化新分配的 Buffer 的内容，就有可能在无意中为他们的代码引入安全性与可靠性问题。为了使 Buffer 实例的创建更可靠、更不容易出错，各种 new Buffer() 构造函数已被 废弃，并由 Buffer.from()、Buffer.alloc()、和 Buffer.allocUnsafe() 方法替代。 Node.js 建议开发者们应当把所有正在使用的 new Buffer() 构造函数迁移到这些新的 API 上。 Buffer 的转换Buffer对象与普通的 JavaScript 字符串的互相转换，需要指定编码格式。目前Node.js 目前支持以下的字符编码。 ‘ascii’ - 仅支持 7 位 ASCII 数据。 ‘utf8’ ‘utf16le’ ‘ucs2’ ‘base64’ ‘latin1’ ‘binary’ ‘hex’ 12345678// 字符串转Bufferconst buf = Buffer.from(&apos;node&apos;, &apos;ascii&apos;); // Buffer转hex编码字符串 - 输出 6e6f6465console.log(buf.toString(&apos;hex&apos;));// Buffer转base64编码字符串 - 输出 bm9kZQ==console.log(buf.toString(&apos;base64&apos;)); 字符串转BufferBuffer.from(string[, encoding])encoding 不传参数会默认utf8编码进行转码和存储。 字符串转Buffer实例方法buf.toString([encoding[, start[, end]]])encoding 解码使用的字符编码。默认: ‘utf8’。start 开始解码的字节偏移量。默认: 0。end 结束解码的字节偏移量（不包含）。 默认: buf.length。注：如果Buffer对象由多种编码写入，就需要在局部指定定不同的编码，才能转换回正常的编码。 判断一个对象是否是Buffer对象Buffer.isBuffer(obj)如果 obj 是一个 Buffer 则返回 true ，否则返回 false 。12const buf1 = Buffer.alloc(10);console.log(Buffer.isBuffer(buf1)) # 返回true 合并BufferBuffer.concat(list[, totalLength])list &lt;Array&gt; 要合并的 Buffer 或 Uint8Array 实例的数组totalLength &lt;integer&gt; 合并时 list 中 Buffer 实例的总长度返回一个合并了 list 中所有 Buffer 实例的新建的 Buffer 。如果 list 中没有元素、或 totalLength 为 0 ，则返回一个新建的长度为 0 的 Buffer 。如果没有提供 totalLength ，则从 list 中的 Buffer 实例计算得到。 为了计算 totalLength 会导致需要执行额外的循环，所以提供明确的长度会运行更快。如果提供了 totalLength，totalLength 必须是一个正整数。如果从 list 中计算得到的 Buffer 长度超过了 totalLength，则合并的结果将会被截断为 totalLength 的长度。12345678const buf1 = Buffer.from(&apos;蓝&apos;);const buf2 = Buffer.from(&apos;胖&apos;);const buf3 = Buffer.from(&apos;纸&apos;);const len = buf1.length + buf2.length + buf3.length;console.log(len) # 输出9 一个汉字三个字节console.log(Buffer.concat([buf1, buf2, buf3], len).toString()) 获取字符长度Buffer.byteLength(string[, encoding])encoding 不传参数会默认utf8编码1console.log(Buffer.byteLength(&apos;蓝胖&apos;)) # 输出6 一个汉字三个字节 参考http://nodejs.cn/api/buffer.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"global对象","slug":"global对象","date":"2018-02-02T14:33:27.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"global对象.html","link":"","permalink":"http://blog.langpz.com/global对象.html","excerpt":"global全局对象在Node.js里面有一个叫global的对象，它的属性和方法可以在全局中访问到，即全局变量。在游览器Javascript中全局对象是window，而Node.js中全局对象是global。","text":"global全局对象在Node.js里面有一个叫global的对象，它的属性和方法可以在全局中访问到，即全局变量。在游览器Javascript中全局对象是window，而Node.js中全局对象是global。 全局变量在所有模块中均可使用。 但以下变量的作用域只在模块内12345__dirname__filenameexportsmodulerequire() __dirname1console.log(__dirname) # 获取当前模块的文件所在的文件夹名称的绝对路径 __filename1console.log(__filename) # 获取当前模块的文件名称-解析后的绝对路径 setImmediate(callback[, …args])123setImmediate(() =&gt; &#123; console.log(&apos;坑呀&apos;) # 把参数函数放到下一个时间环中执行&#125;); clearImmediate(immediate)1234let a = setImmediate(() =&gt; &#123; console.log(&apos;坑呀&apos;) # 取消一个由 setImmediate() 创建的 Immediate 对象&#125;);clearImmediate(a) process 进程process.cwd()1console.log(process.cwd()) # 方法返回 Node.js 进程当前工作的目录。 process.argv1234567891011// a.jsconsole.log(process.argv) // 执行node a.js a=1 b=2// 输出[ &apos;C:\\\\Program Files\\\\nodejs\\\\node.exe&apos;, &apos;c:\\\\Users\\\\windows\\\\Desktop\\\\新建文件夹\\\\a.js&apos;, &apos;a=1&apos;, &apos;b=2&apos; ] process.argv 属性返回一个数组，这个数组包含了启动Node.js进程时的命令行参数。第一个元素为process.execPath。如果需要获取argv[0]的值请参见 process.argv0。第二个元素为当前执行的JavaScript文件路径。剩余的元素为其他命令行参数。 process.env1console.log(process.env) # 返回一个包含用户环境信息的对象 可以修改这个对象12process.env.foo = &apos;bar&apos;;console.log(process.env.foo); # 输出bar 但是不可以用这种方法去修改1node http.js &apos;process.env.foo = &quot;bar&quot;&apos; 用 delete从process.env中删除一个属性123process.env.foo = &apos;bar&apos;;delete process.env.foo;console.log(process.env.foo); # 输出 undefined 注: 在process.env中新增一个属性，会将属性值转换成字符串、 在Windows系统下，环境变量是不区分大小写的。 process.memoryUsage()1234567console.log(process.memoryUsage()) # 返回Node.js进程的内存使用情况的对象，该对象每个属性值的单位为字节。// 输出&#123; rss: 23588864, heapTotal: 7708672, heapUsed: 4430656, external: 8224 &#125; rss（resident set size）：所有内存占用，包括指令区和堆栈。heapTotal：”堆”占用的内存，包括用到的和没用到的。heapUsed：用到的堆的部分。external： V8 引擎内部的 C++ 对象占用的内存。 process.chdir(directory)1234567console.log(process.cwd())process.chdir(&apos;..&apos;) # 方法变更Node.js进程的当前工作目录，如果变更目录失败会抛出异常(例如，如果指定的目录不存在)。console.log(process.cwd())// 输出 &apos;..&apos;切换到上一级目录C:\\Users\\windows\\Desktop\\新建文件夹C:\\Users\\windows\\Desktop process.nextTick(callback[, …args])123process.nextTick(function()&#123; console.log(&apos;nextTick&apos;); # 放到当前任务末尾执行&#125;) 参考http://www.ruanyifeng.com/blog/2017/04/memory-leak.htmlhttp://nodejs.cn/api/process.html#process_processhttp://nodejs.cn/api/globals.html","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"http模块","slug":"http模块","date":"2018-01-15T17:05:37.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"http模块.html","link":"","permalink":"http://blog.langpz.com/http模块.html","excerpt":"http模块http模块是node提供搭建http客户端和服务端的核心模块。","text":"http模块http模块是node提供搭建http客户端和服务端的核心模块。 什么是客户端和什么是服务端客户端（Client），是指与服务器相对应，为客户提供本地服务的程序。一般安装在普通的用户机上，需要与服务端互相配合运行。互联网发展以后，较常用的客户端包括了如万维网使用的网页浏览器，收寄电子邮件时的电子邮件客户端，以及即时通信的客户端软件等。服务端(Server)，是为客户端服务的，服务的内容诸如向客户端提供资源，保存客户端数据。是实现游戏特色化的重要途径，也是最直接可以通过游戏表现出来的技术，比如你要修改某个NPC的参数，重加载后，在游戏内立刻体现出来。 搭建一个服务器123456789var http = require(&apos;http&apos;);var app = http.createServer(function(request,response)&#123; response.writeHead(200, &#123;&apos;Content-Type&apos;: &apos;text/plain&apos;&#125;); response.write(&apos;入坑了...&apos;); response.end();&#125;);app.listen(8000); http.createServer() 创建一个服务器的实例，它的参数是一个函数，函数里有两个参数request和response，request是从客户端的请求、response是服务端的响应。输入 http://localhost:8000 就可以看到（入坑了…）这几个字。代表创建成功。response.writeHead() 发送一个http响应头给请求。response.write() 向客户端发送响应体。response.end() 结束响应。listen() 监听的端口。 客户端向HTTP服务器发起请求http.request(options[, callback])12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// request.jsvar http = require(&apos;http&apos;);var querystring = require(&apos;querystring&apos;);const postData = querystring.stringify(&#123; &apos;msg&apos;: &apos;Hello World!&apos;&#125;);const options = &#123; hostname: &apos;localhost&apos;, port: 80, path: &apos;/&apos;, method: &apos;POST&apos;, headers: &#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;, &apos;Content-Length&apos;: Buffer.byteLength(postData) &#125;&#125;;const req = http.request(options, (res) =&gt; &#123; console.log(`状态码: $&#123;res.statusCode&#125;`); console.log(`响应头: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding(&apos;utf8&apos;); res.on(&apos;data&apos;, (chunk) =&gt; &#123; console.log(`响应主体: $&#123;chunk&#125;`); &#125;); res.on(&apos;end&apos;, () =&gt; &#123; console.log(&apos;响应中已无数据。&apos;); &#125;);&#125;);req.on(&apos;error&apos;, (e) =&gt; &#123; console.error(`请求遇到问题: $&#123;e.message&#125;`);&#125;);// 写入数据到请求主体req.write(postData);req.end();// sever.jslet http = require(&apos;http&apos;);let querystring = require(&apos;querystring&apos;);let app = http.createServer( (res,req) =&gt; &#123; let str = &apos;&apos;; res.on(&apos;data&apos;, (data) =&gt; &#123; str += data &#125;); res.on(&quot;end&quot;, () =&gt; &#123; str = querystring.parse(str) console.log(str) // 向客户端返回数据 req.end(`提交成功了: $&#123;str.msg&#125;`) &#125;) &#125;);app.listen(80); 客户端会输出1234状态码: 200响应头: &#123;&quot;date&quot;:&quot;Fri, 02 Feb 2018 03:37:39 GMT&quot;,&quot;connection&quot;:&quot;close&quot;,&quot;content-length&quot;:&quot;29&quot;&#125;响应主体: 提交成功了: Hello World!响应中已无数据。 我们可以写个定时器用request方法，一直向某个网站提交信息。 options: Object | string | URL protocol &lt;string&gt; 使用的协议。默认为 http:。 host &lt;string&gt; 请求发送至的服务器的域名或 IP 地址。默认为 localhost。 hostname &lt;string&gt; host 的别名。为了支持 url.parse()，hostname 优先于 host。 family &lt;number&gt; 当解析 host 和 hostname 时使用的 IP 地址族。 有效值是 4 或 6。当未指定时，则同时使用 IP v4 和 v6。 port &lt;number&gt; 远程服务器的端口。默认为 80。 localAddress &lt;string&gt; 为网络连接绑定的本地接口。 socketPath &lt;string&gt; Unix 域 Socket（使用 host:port 或 socketPath）。 method &lt;string&gt; 指定 HTTP 请求方法的字符串。默认为 ‘GET’。 path &lt;string&gt; 请求的路径。默认为 ‘/‘。 应包括查询字符串（如有的话）。如 ‘/index.html?page=12’。 当请求的路径中包含非法字符时，会抛出异常。 目前只有空字符会被拒绝，但未来可能会变化。 headers &lt;Object&gt; 包含请求头的对象。 auth &lt;string&gt; 基本身份验证，如 ‘user:password’ 用来计算 Authorization 请求头。 agent &lt;http.Agent&gt; | &lt;boolean&gt; 控制 Agent 的行为。 可能的值有：undefined (默认): 对该主机和端口使用 http.globalAgent。 Agent 对象：显式地使用传入的 Agent。false: 创建一个新的使用默认值的 Agent。 createConnection &lt;Function&gt; 当不使用 agent 选项时，为请求创建一个 socket 或流。 这可以用于避免仅仅创建一个自定义的 Agent 类来覆盖默认的 createConnection 函数。详见 agent.createConnection()。 timeout &lt;number&gt;: 指定 socket 超时的毫秒数。 它设置了 socket 等待连接的超时时间。 发起get请求 http.get(options[, callback])123456789101112131415161718192021222324252627var http = require(&apos;http&apos;);http.get(&apos;http://blog.langpz.com&apos;, (res) =&gt; &#123; const &#123; statusCode &#125; = res; let str = &quot;&quot;; let error; if (statusCode !== 200) &#123; error = new Error(&apos;请求失败。\\n&apos; + `状态码: $&#123;statusCode&#125;`); &#125; res.on(&quot;data&quot;, (data) =&gt; &#123; str += data &#125;); if (error) &#123; console.error(error.message); // 消耗响应数据以释放内存 res.resume(); return; &#125; res.on(&quot;end&quot;, () =&gt; &#123; console.log(str) &#125;) &#125;).on(&apos;error&apos;, (e) =&gt; &#123; console.error(`出错了: $&#123;e.message&#125;`);&#125;); 网站内容就爬下来了。该方法与 http.request() 唯一的区别是它设置请求方法为 GET 且自动调用 req.end()。 参考https://zh.wikipedia.org/wiki/%E5%AE%A2%E6%88%B7%E7%AB%AFhttps://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E7%AB%AFhttp://nodejs.cn/api/http.html#http_http_request_options_callback","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Node模块机制","slug":"Node模块机制","date":"2018-01-08T16:11:02.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"Node模块机制.html","link":"","permalink":"http://blog.langpz.com/Node模块机制.html","excerpt":"Node模块机制JavaScript没有模块系统、标准库比较少、没有标准接口、缺乏包管理系统。所以JavaScript社区提出了commonjs规范来解决这些问题。","text":"Node模块机制JavaScript没有模块系统、标准库比较少、没有标准接口、缺乏包管理系统。所以JavaScript社区提出了commonjs规范来解决这些问题。一个Node应用由模块组成，每个js文件就是一个独立模块。npm基于commonjs实现包的管理使我们开发Node.js更方便。 commonjs规范引用模块在commonjs规范中，定义了 require() 方法，这个方法接受一个模块的标识。1var math = require(&apos;math&apos;); 定义模块模块有自己的作用域。在模块里面定义的变量、函数、类，都是私有的，对其他文件不可见。 上下文中提供了一个 exports 对象可以导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个 module 对象，它代表当前模块，exports 是 module 的属性。12345// math.jsfunction add(a,b)&#123; return a + b;&#125;exports.add = add; # 导出一个add的方法 再新建一个文件就可以用 require()引用这个模块了123// app.jsvar math = require(&apos;math&apos;);console.log(math.add(1,2)); # 3 模块标识模块标识就是传递给 require() 方法的参数，它必须是符合小驼峰命名的规范，或者以 .. 开头的相对路径，或者绝对路径。它可以没有文件后缀名.js。 模块缓存加载模块后会被缓存,多次加载还是同一个对象。查看模块缓存 require.cache查看模块绝对路径 require.resolve(./math.js)删除模块的缓存 require.cache[require.resolve(./math.js)] 模块的循环加载123456789101112131415161718192021// a.jsconsole.log(&apos;a 开始&apos;);exports.done = false;const b = require(&apos;./b.js&apos;);console.log(&apos;在 a 中，b.done = %j&apos;, b.done);exports.done = true;console.log(&apos;a 结束&apos;);// b.jsconsole.log(&apos;b 开始&apos;);exports.done = false;const a = require(&apos;./a.js&apos;);console.log(&apos;在 b 中，a.done = %j&apos;, a.done);exports.done = true;console.log(&apos;b 结束&apos;);// main.jsconsole.log(&apos;main 开始&apos;);const a = require(&apos;./a.js&apos;);const b = require(&apos;./b.js&apos;);console.log(&apos;在 main 中，a.done=%j，b.done=%j&apos;, a.done, b.done); 当 main.js 加载 a.js 时，a.js 又加载 b.js。 此时，b.js 会尝试去加载 a.js。 为了防止无限的循环，会返回一个 a.js 的 exports 对象的 未完成的副本 给 b.js 模块。 然后 b.js 完成加载，并将 exports 对象提供给 a.js 模块。 当 main.js 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是： 123456789node main.jsmain 开始a 开始b 开始在 b 中，a.done = falseb 结束在 a 中，b.done = truea 结束在 main 中，a.done=true，b.done=true module对象module.children 被该模块引用的模块对象。module.id 模块的标识符。 通常是完全解析后的文件名。module.parent 最先引用该模块的模块。module.paths 模块的搜索路径。… 更多去官网查询 Node的模块在Node中，模块分为两类：一类是Node提供的模块，称为核心模块。另外一类是用户编写的模块，称为文件模块。核心模块定义在 Node.js 源代码的 lib/ 目录下。require() 总是会优先加载核心模块。 例如，require(‘http’) 始终返回内置的 HTTP 模块，即使有同名文件。 module.exports和exports区别exports是module.exports对象的引用12345678910111213function require(/* ... */) &#123; const module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // 模块代码在这。在这个例子中，定义了一个函数。 function someFunc() &#123;&#125; exports = someFunc; // 此时，exports 不再是一个 module.exports 的快捷方式， // 且这个模块依然导出一个空的默认对象。 module.exports = someFunc; // 此时，该模块导出 someFunc，而不是默认对象。 &#125;)(module, module.exports); return module.exports;&#125; 参考http://nodejs.cn/api/modules.html#modules_cycles","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"什么是Node.js","slug":"什么是Node-js","date":"2018-01-08T13:29:21.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"什么是Node-js.html","link":"","permalink":"http://blog.langpz.com/什么是Node-js.html","excerpt":"什么是Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 可以让JavaScript运行在服务器端一个解析器。它实现了操作磁盘文件和搭建HTTP服务器，模块，操作系统进程等一些以前js没有实现功能。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。","text":"什么是Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 可以让JavaScript运行在服务器端一个解析器。它实现了操作磁盘文件和搭建HTTP服务器，模块，操作系统进程等一些以前js没有实现功能。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 I/O输入(Input)： 从系统写入文件输出(Output)： 从系统读取文件 同步和异步同步是指发起一个调用之后主线程挂起，调用者主动等待调用返回结果。异步是指发起一个调用之后主线程还可以发起别的调用，被调用者通知调用者返回结果。 阻塞式和非阻塞式非阻塞式是指发起一个调用不会阻塞主线程的执行，非阻塞式是实现异步的前提。阻塞式是指发起一个调用主线程是被挂起，调用完成后才可以执行其他操作。 单线程和多线程单线程是指程序按顺序执行,前面的程序执行完后面才程序可以执行。多线程是指同时执行多个程序，当前程序执行不影响其他程序执行。 事件驱动这种模型的程序运行流程是由用户的动作（如鼠标的按键，键盘的按键动作）或者是由其他程序的消息来决定的。","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"VSCode 配置Node调试环境","slug":"VSCode-配置Node调试环境","date":"2018-01-05T17:17:59.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"VSCode-配置Node调试环境.html","link":"","permalink":"http://blog.langpz.com/VSCode-配置Node调试环境.html","excerpt":"VSCode 配置Node调试环境我们在写js的时候需要调试打开浏览器按F12（开发者工具）就可以打断点去看程序写得对不对。但是在node.js里面就没有办法了，因为是在命令行执行的没法打断点一个个console的话效率太低，所以这个时候就需要VSCode来辅助我们开发node.js。","text":"VSCode 配置Node调试环境我们在写js的时候需要调试打开浏览器按F12（开发者工具）就可以打断点去看程序写得对不对。但是在node.js里面就没有办法了，因为是在命令行执行的没法打断点一个个console的话效率太低，所以这个时候就需要VSCode来辅助我们开发node.js。 首先下载VSCodehttps://code.visualstudio.com/下载对应系统的安装包 下载VSCode 新建文件打开VSCode新建一个文件夹hello，在里面再新建一个app.js 新建文件 app.js的代码12345for (let index = 0; index &lt; 5; index++) &#123; console.log(index) &#125;console.log(&apos;Hello Word&apos;) 开始调试再点调试，快捷键（Ctrl+Shift+D）,添加配置选择Node.js。注： “program”: “${workspaceFolder}/app.js” /app.js 可以是任何名字，但是一定要是你入口文件。 调试 打断点开始打断点。 打断点 执行app.js操作和浏览器调试类似。 执行app.js","categories":[],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"http://blog.langpz.com/tags/VSCode/"}]},{"title":"Git配置https免用户名和密码提交","slug":"Git配置https免用户名和密码提交","date":"2018-01-03T14:15:36.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"Git配置https免用户名和密码提交.html","link":"","permalink":"http://blog.langpz.com/Git配置https免用户名和密码提交.html","excerpt":"Git配置https免用户名和密码提交我们如果是通过git clone https://xxx 下载的项目每次Push的时候需要输入用户名和密码，其实Git可以通过配置实现免密码提交。","text":"Git配置https免用户名和密码提交我们如果是通过git clone https://xxx 下载的项目每次Push的时候需要输入用户名和密码，其实Git可以通过配置实现免密码提交。 在Git Bash 里面输入命令。1git config --global credential.helper store 然后再提交输入用户名和密码提交完成后，用户名和密码就被保存了，下次再提交就不用再输入了。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://blog.langpz.com/tags/Git/"}]},{"title":"javascript数组去重","slug":"javascript数组去重","date":"2018-01-02T10:25:35.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"javascript数组去重.html","link":"","permalink":"http://blog.langpz.com/javascript数组去重.html","excerpt":"javascript数组去重原理：在数组原型上扩展方法，遍历当前数组把数组的每一项存在json对象里面，如果json存在当前遍历的值就代表重复了，否则把当前遍历的值添加到一个新的数组，最后返回新的数组。","text":"javascript数组去重原理：在数组原型上扩展方法，遍历当前数组把数组的每一项存在json对象里面，如果json存在当前遍历的值就代表重复了，否则把当前遍历的值添加到一个新的数组，最后返回新的数组。 1234567891011Array.prototype.removal = function removal()&#123; var hash = &#123;&#125;, arr = []; for(var i = 0; i &lt; this.length; i++)&#123; if(!hash[this[i]])&#123; arr.push(this[i]); &#125; hash[this[i]] = 1; &#125; return arr;&#125; javascript数组去重","categories":[],"tags":[{"name":"数组","slug":"数组","permalink":"http://blog.langpz.com/tags/数组/"}]},{"title":"Hexo博客多端同步问题","slug":"Hexo博客多端同步问题","date":"2017-12-29T16:38:22.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"Hexo博客多端同步问题.html","link":"","permalink":"http://blog.langpz.com/Hexo博客多端同步问题.html","excerpt":"Hexo博客多端同步问题搭完博客，发现只有公司电脑上有源文件，如果回家就没发继续更新博客了。也不能拿着U盘到处拷贝。所以就把博客源文件放到github上解决同步问题。","text":"Hexo博客多端同步问题搭完博客，发现只有公司电脑上有源文件，如果回家就没发继续更新博客了。也不能拿着U盘到处拷贝。所以就把博客源文件放到github上解决同步问题。 博客源文件同步在博客根目录执行 123456git initgit remote add origin git@github.com:lanpangzhi/lanpangzhi.github.io.git # 添加远程仓库 注意这里要添加你自己的仓库 lanpangzhi 换成你自己的用户名git checkout -b hexo # 新建hexo分支并切换到hexo分支git add . # 所有变化提交到暂存区git commit -m &quot;解决同步问题&quot; # 提交文件git push origin hexo # 推送hexo分支 这就成功了，github上已经有博客的源文件了。 github查看提交成功 推荐把hexo设置为默认分支。 hexo设置为默认分支 git submodule 实现第三方主题同步因为之前是直接把第三方主题克隆到博客目录，有什么改动是无法推送到作者Git仓库的，这个时候需要把第三方主题的项目Fork到自己仓库，自己账号下生成一个同名的仓库，并对应一个url，我们应该git clone自己账号下仓库的url。 Fork第三方主题 执行如下操作。1git submodule add git@github.com:lanpangzhi/hexo-theme-next.git themes/next 把自己仓库下面第三方主题添加到Git子模块， 注 : themes/next 这里的目录是因为我用的next主题才会写themes/next 如果你用的不是next请把next替换成你的第三方主题文件夹名字。 博客的根目录会多一个.gitmodules文件,这是一个配置文件，保存了项目 URL 和你拉取到的本地子目录。 .gitmodules文件 这就添加成功了，然后执行如下操作。123git add . # 所有变化提交到暂存区git commit -m &quot;添加第三方主题Git子模块&quot; # 提交文件git push origin hexo # 推送hexo分支 更换电脑同步博客和第三方主题同步博客电脑上一定要先node和git，执行如下操作。 1234npm install hexo-cli -g # 先安装hexo的脚手架git clone git@github.com:lanpangzhi/lanpangzhi.github.io.git # 下载项目，因为hexo 是默认分支，所以这里直接会下载hexo分支npm i # 安装依赖hexo s # 启动服务器 剩下的就自行操作了。博客已经完成了同步。 注：每次写完文章部署网站后，记得再执行如下操作。 123git add . # 所有变化提交到暂存区git commit -m &quot;新增xxx文章&quot; # 提交文件git push origin hexo # 推送hexo分支 同步第三方主题在博客根目录执行如下操作。12git submodule init # 初始化本地配置文件git submodule update # 拉取子模块 如果第三方主题有修改的，修改完成后在第三方主题目录执行。 123git add . # 所有变化提交到暂存区git commit -m &quot;修改主题xxxx&quot; # 提交文件git push origin master # 推送master分支 这样就会把修改的主题推送到自己的仓库。 修改的主题推送到自己的仓库 这样就实现多端同步了。 参考http://devtian.me/2015/03/17/blog-sync-solutionhttps://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"}]},{"title":"npm install 报错提示请使用管理员","slug":"npm-install-报错提示请使用管理员","date":"2017-12-27T11:07:20.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"npm-install-报错提示请使用管理员.html","link":"","permalink":"http://blog.langpz.com/npm-install-报错提示请使用管理员.html","excerpt":"npm install 报错提示请使用管理员之前把node升级了，npm自动升级到 npm5 再npm install xxx 会报如下图错误","text":"npm install 报错提示请使用管理员之前把node升级了，npm自动升级到 npm5 再npm install xxx 会报如下图错误Please try running this command again as root/Administrator 解决方案: 后面加上–no-optional 或者降级 5.3 版本 升级更高版本 npm install hexo-cli -g --no-optional 参考https://stackoverflow.com/questions/46020018/error-eperm-operation-not-permitted-unlink-d-sources-node-modules-fseven","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"nvm管理node.js版本（Windows系统）","slug":"nvm管理node-js版本（Windows系统）","date":"2017-12-26T14:03:59.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"nvm管理node-js版本（Windows系统）.html","link":"","permalink":"http://blog.langpz.com/nvm管理node-js版本（Windows系统）.html","excerpt":"nvm管理node版本在开发过程中偶尔会碰见不同项目依赖的node版本不一样，而node没有提供自动切换版本的功能，这个时候就需要nvm出马了，n也可以管理node版本（注：不支持Windows）","text":"nvm管理node版本在开发过程中偶尔会碰见不同项目依赖的node版本不一样，而node没有提供自动切换版本的功能，这个时候就需要nvm出马了，n也可以管理node版本（注：不支持Windows） 先去下载nvm-windows下载链接地址 注：目前版本1.1.6。如果你之前安装过node，先卸载掉。 安装nvm-windows刚才下载的是 nvm-setup.zip 这个文件 1输入 nvm 这就安装成功了。 安装node安装最新稳定版 node 1nvm install latest 安装指定版本 node 1nvm install 8.9.0 切换node版本1nvm use 9.3.0 nvm list 显示当前安装node版本列表 * 代表当前使用的版本 注: 安装的npm全局模块不会在各个版本的node.js之间共享。还有可能有些npm包不支持当前使用的node版本 nvm基本命令nvm arch [32|64]: 设置node是以32还是64位模式运行。 指定32或64来覆盖默认操作系统版本。nvm install [arch]: version 版本号 例如 8.9.0 或者 latest（最新稳定版）,[arch]可选、指定是否安装32位或64位版本（默认为系统架构），将[arch]设置为 all 安装32和64位版本。nvm list [available]: 显示当前安装node版本列表 * 代表当前使用的版本，在末尾输入 available 显示可供下载的所有版本列表。nvm on: 使用Node.js版本管理。nvm off: 禁用node.js版本管理（不会卸载任何东西）。nvm proxy [url]: 设置下载的代理，将[url]留空以查看当前代理。 将[url]设置为 none 以删除代理。nvm uninstall : 卸载指定的node版本。nvm use [arch]: 切换指定的node版本，可选[arch]32和64位版本。nvm root : 设置nvm存放不同版本的node.js的目录。 如果没有设置 path ，则显示当前的根目录。nvm version: 显示Windows的NVM的当前运行版本。nvm node_mirror : 设置node节点镜像。国内可以使用 https://npm.taobao.org/mirrors/node/nvm npm_mirror : 设置npm节点镜像。国内可以使用 https://npm.taobao.org/mirrors/npm/ 参考https://github.com/coreybutler/nvm-windows","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Hexo+Next集成Algolia搜索","slug":"Hexo-Next集成Algolia搜索","date":"2017-12-22T13:13:18.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"Hexo-Next集成Algolia搜索.html","link":"","permalink":"http://blog.langpz.com/Hexo-Next集成Algolia搜索.html","excerpt":"集成Algolia搜索起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。注：Algolia搜索在版本 5.1.0 中引入，要使用此功能请确保所使用的 NexT 版本在此之后","text":"集成Algolia搜索起因Swiftype现在收费了，也没有免费版本。Local Search搜索体验不好，微搜索Next官网上描述太少！所以选择Algolia。注：Algolia搜索在版本 5.1.0 中引入，要使用此功能请确保所使用的 NexT 版本在此之后 首先注册Algolia账户Algolia 登陆页面https://www.algolia.com/users/sign_in，可以使用 GitHub 或者 Google 账户直接登录，也可以注册一个新账户。我直接用谷歌账户登陆了，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。 注册完成后，创建一个新的 Index，这个 index name 之后会用到Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 Hexo Algolia 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装： 1npm install hexo-algolia --save # 目前最新版本是1.2.4，下面的操作都是基于这个版本的文档 获取 Key，更新站点根目录配置 前往站点根目录打开_config.yml添加以下代码 12345# Algolia Search API Keyalgolia: applicationID: &apos;你的Application ID&apos; apiKey: &apos;你的Search-Only API Key&apos; indexName: &apos;输入刚才创建index name&apos; 修改Algolia搜索ACL（访问控制列表） 选中后保存。 操作完成后执行命令123export(windows 为 set) (Powershell 用 $env:) HEXO_ALGOLIA_INDEXING_KEY=你的Search-Only API keyset (Mac和git bash 为 export) (Powershell 用 $env:) HEXO_ALGOLIA_INDEXING_KEY #查看是否设置成功如果没有值就设置失败hexo algolia 成功后修改Next主题配置文件更改Next主题配置文件，找到 Algolia Search 配置部分： 123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;我们没有找到任何搜索结果: $&#123;query&#125;&quot; hits_stats: &quot;找到约$&#123;hits&#125;条结果（用时$&#123;time&#125;ms）&quot; 将 enable 改为 true 即可，根据需要你可以调整 labels 中的文本。这个是我修改的文本。 总结一下集成遇到的BUGPlease provide an Algolia index name in your hexo _config.yml flle 原因：Algolia Search API Key indexName 错了 解决方案：看下之前新建index的名字 Not enough rights to update an object near 原因：没有修改Algolia搜索ACL（访问控制列表） 解决方案： 按1.4操作勾选上就可以 移动端遮罩盖住搜索 原因：遮罩的z-index值太高，我的next主题是5.1.3版本可能其他版本没有这个BUG 解决方案： 找到\\themes\\next\\source\\css_common\\components\\third-party 下面的algolia-search.styl 文件 第8行追加12+mobile() z-index: 1000 参考http://theme-next.iissnan.com/third-party-services.html#algolia-searchhttps://github.com/oncletom/hexo-algolia","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://blog.langpz.com/tags/Hexo/"}]},{"title":"npm使用介绍","slug":"npm使用介绍","date":"2017-12-20T14:56:09.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"npm使用介绍.html","link":"","permalink":"http://blog.langpz.com/npm使用介绍.html","excerpt":"npm使用介绍npm是随同NodeJS一起安装的包管理工具、官网https://www.npmjs.com","text":"npm使用介绍npm是随同NodeJS一起安装的包管理工具、官网https://www.npmjs.com 创建一个模块1npm init 会提示你输入包名等，然后生成一个package.json文件,文件内容如下1234567891011&#123; &quot;name&quot;: &quot;xxx&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;lanpang&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; package.json文件属性说明 name - 包名 version - 包的版本号 description - 包的描述，方便在npm search中搜索 main - main字段配置一个文件名指向模块的入口程序。如果你包的名字叫xxx，然后用户require(“xxx”)，main配置的模块的exports对象会被返回 scripts - 是一个由脚本命令组成的hash对象，他们在包不同的生命周期中被执行。key是生命周期事件，value是要运行的命令 author - 作者 license - 许可证，让人知道使用的权利和限制的更多说明请查看https://github.com/ericdum/mujiang.info/issues/6/ 安装模块1234npm install (Module Name) options # 语法npm install express # 本地安装npm install express -g # 全局安装npm install express@1.0.0 # 安装指定版本 npm 的包安装分为本地安装（local）、全局安装（global）两种。 本地安装：将安装包放在当前目录下的 ./node_modules 下。 本地安装：可以通过 require(Module Name) 来引入本地安装的包。 全局安装：node安装目录/node_modules。 全局安装：可以直接在命令行里使用。 查看全局安装目录1npm list -g --depth=0 安装包信息将加入到dependencies（生产阶段的依赖）12npm install express --save # npm5已经将--save变成了默认参数，执行 install 依赖包时默认都会带上，除非加上 --no-save。npm install express -S # 缩写 安装包信息将加入到devDependencies（开发和测试阶段的依赖）12npm install gulp --save-devnpm install gulp -D # 缩写 注: 包的依赖都被写入了package.json文件后，他人git或者svn下载项目可以通过npm install 安装项目依赖的包。 卸载包1npm uninstall gulp # 如果你安装的包带参数 --save 或者 --save-dev 必须npm uninstall gulp 要添加对应参数 更新包更新本地包1npm update gulp 更新全局包1npm update gulp -g 检查包是否已经过时检查本地包1npm outdated 检查全局包1npm outdated -g --depth=0 搜索包1npm search express 查看包安装信息查看本地包1npm list 查看全局包1npm list -g npm-scripts可以修改package.json文件scripts增加自定义命令，执行一些操作123&quot;scripts&quot;: &#123; &quot;start&quot; : &quot;gulp&quot;&#125; 此时在cmd或git bash中输入npm start 就会执行gulp命令 包版本号默认1.0.0 bug修复和其他小的变化：修补程序版本，增加最后一个数字，例如1.0.1。 不破坏现有功能的新功能：次要版本，增加中间数字，例如1.1.0。 主要版本，增加第一个数字，例如2.0.0。","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"国内学生云主机优惠整理","slug":"国内学生云主机优惠整理","date":"2017-12-20T10:10:37.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"国内学生云主机优惠整理.html","link":"","permalink":"http://blog.langpz.com/国内学生云主机优惠整理.html","excerpt":"腾讯云云+校园扶持计划10元／月链接地址","text":"腾讯云云+校园扶持计划10元／月链接地址 阿里云云翼计划9.9元／月 59元／半年 118元／年链接地址 美团云云帆校园扶持计划8.8元／月链接地址 京东云跃云计划8.8元／月 88 元／年链接地址 注： 必须是要在籍大学生进行学生认证才可以购买","categories":[],"tags":[{"name":"云主机","slug":"云主机","permalink":"http://blog.langpz.com/tags/云主机/"}]},{"title":"css实现单行、多行文本溢出显示省略号","slug":"css实现单行、多行文本溢出显示省略号","date":"2017-12-19T10:58:41.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"css实现单行、多行文本溢出显示省略号.html","link":"","permalink":"http://blog.langpz.com/css实现单行、多行文本溢出显示省略号.html","excerpt":"css实现单行文本溢出显示省略号123white-space: nowrap; // 规定段落中的文本不进行换行overflow: hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号","text":"css实现单行文本溢出显示省略号123white-space: nowrap; // 规定段落中的文本不进行换行overflow: hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号 css实现多行文本溢出显示省略号12345display: -webkit-box; // 设置弹性盒子模型overflow : hidden; // 溢出隐藏text-overflow: ellipsis; // 文本溢出显示省略号-webkit-line-clamp: 2; // 限制在一个块元素显示的文本的行数-webkit-box-orient: vertical; // 属性规定框的子元素应该被水平或垂直排列。 注：因为用了webkit的私有属性，建议只在移动端使用。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://blog.langpz.com/tags/css/"}]},{"title":"npm设置淘宝镜像","slug":"npm设置淘宝镜像","date":"2017-12-15T16:06:34.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"npm设置淘宝镜像.html","link":"","permalink":"http://blog.langpz.com/npm设置淘宝镜像.html","excerpt":"npm设置淘宝镜像 我们通过npm install xxx 安装包的过程会特别慢，或者安装半天突然报错。这是因为npm镜像地址在国外，所以访问会慢有的时候还访问不到…..（天朝的万能的防火墙）","text":"npm设置淘宝镜像 我们通过npm install xxx 安装包的过程会特别慢，或者安装半天突然报错。这是因为npm镜像地址在国外，所以访问会慢有的时候还访问不到…..（天朝的万能的防火墙） 我们可以通过设置淘宝镜像来解决问题 淘宝镜像同步频率目前为10分钟一次以保证尽量与官方服务同步。 设置成淘宝镜像 1npm config set registry http://registry.npm.taobao.org 查看设置是否成功 1npm get registry 注意如果你换成淘宝镜像的话，会影响你发布模块，这时候需要换回npm官网的镜像1npm config set registry https://registry.npmjs.org","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://blog.langpz.com/tags/npm/"}]},{"title":"node.js Windows下安装（笔记）","slug":"node-js-Windows下安装","date":"2017-12-12T16:26:01.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"node-js-Windows下安装.html","link":"","permalink":"http://blog.langpz.com/node-js-Windows下安装.html","excerpt":"首先去Node.js中文网下载安装包 偶数位为稳定版本，奇数位为非稳定版本（开发版） 稳定版本中已发布的API是不会改变的 奇数开头的开发版就是会不断变化更新","text":"首先去Node.js中文网下载安装包 偶数位为稳定版本，奇数位为非稳定版本（开发版） 稳定版本中已发布的API是不会改变的 奇数开头的开发版就是会不断变化更新 点这里去下载 如下图，选择系统对应的位数下载 双击打开你下载node-v8.9.0-x64.msi安装包 一路下一步 Node.js默认安装目录，你也可以点Change修改目录，点击下一步(Next) 点击下一步(Next) 点击安装(Install) 安装完检测PATH环境变量是否配置Node.js123win + r输入 cmd 回车输入 node -v 和 npm -v 会显示你安装node和npm的版本","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://blog.langpz.com/tags/Node-js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-12T16:00:01.000Z","updated":"2018-06-21T08:05:23.865Z","comments":true,"path":"hello-world.html","link":"","permalink":"http://blog.langpz.com/hello-world.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}