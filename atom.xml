<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>蓝胖纸</title>
  
  <subtitle>哆啦A梦</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.langpz.com/"/>
  <updated>2018-06-21T08:05:23.865Z</updated>
  <id>http://blog.langpz.com/</id>
  
  <author>
    <name>lanpangzhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决移动端click事件300毫秒延迟和点透问题</title>
    <link href="http://blog.langpz.com/%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AFclick%E4%BA%8B%E4%BB%B6300%E6%AF%AB%E7%A7%92%E5%BB%B6%E8%BF%9F%E5%92%8C%E7%82%B9%E9%80%8F%E9%97%AE%E9%A2%98.html"/>
    <id>http://blog.langpz.com/解决移动端click事件300毫秒延迟和点透问题.html</id>
    <published>2018-06-21T10:53:59.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解决移动端click事件300毫秒延迟和点透问题"><a href="#解决移动端click事件300毫秒延迟和点透问题" class="headerlink" title="解决移动端click事件300毫秒延迟和点透问题"></a>解决移动端click事件300毫秒延迟和点透问题</h1><p>click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，移动端浏览器就等待 300 毫秒，以判断用户是否再次点击了屏幕。<br><a id="more"></a></p><h2 id="fastclick"><a href="#fastclick" class="headerlink" title="fastclick"></a>fastclick</h2><p>老项目建议用fastclick解决，这样改动起来成本比较小。<br><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a><br>引用fastclick库就可以解决300毫秒延迟和点透问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 原生js调用</span><br><span class="line">if (&apos;addEventListener&apos; in document) &#123;</span><br><span class="line">document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123;</span><br><span class="line">FastClick.attach(document.body);</span><br><span class="line">&#125;, false);</span><br><span class="line">&#125;</span><br><span class="line">// jquery调用</span><br><span class="line">$(function() &#123;</span><br><span class="line">FastClick.attach(document.body);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="使用移动端事件代替click"><a href="#使用移动端事件代替click" class="headerlink" title="使用移动端事件代替click"></a>使用移动端事件代替click</h2><p>例如touchstart 等事件，建议使用Hammer手势库<br><a href="https://github.com/hammerjs/hammer.js" target="_blank" rel="noopener">https://github.com/hammerjs/hammer.js</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = document.querySelector(&apos;.a&apos;);</span><br><span class="line">var hammer = new Hammer(a);</span><br><span class="line">hammer.on(&apos;tap&apos;, function(e) &#123;</span><br><span class="line">  console.log(&quot;2222!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a><br><a href="https://github.com/hammerjs/hammer.js" target="_blank" rel="noopener">https://github.com/hammerjs/hammer.js</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;解决移动端click事件300毫秒延迟和点透问题&quot;&gt;&lt;a href=&quot;#解决移动端click事件300毫秒延迟和点透问题&quot; class=&quot;headerlink&quot; title=&quot;解决移动端click事件300毫秒延迟和点透问题&quot;&gt;&lt;/a&gt;解决移动端click事件300毫秒延迟和点透问题&lt;/h1&gt;&lt;p&gt;click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，移动端浏览器就等待 300 毫秒，以判断用户是否再次点击了屏幕。&lt;br&gt;
    
    </summary>
    
    
      <category term="点透" scheme="http://blog.langpz.com/tags/%E7%82%B9%E9%80%8F/"/>
    
      <category term="移动端" scheme="http://blog.langpz.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue2.0的生命周期</title>
    <link href="http://blog.langpz.com/vue%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>http://blog.langpz.com/vue的生命周期.html</id>
    <published>2018-06-14T09:48:11.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue2-0的生命周期"><a href="#vue2-0的生命周期" class="headerlink" title="vue2.0的生命周期"></a>vue2.0的生命周期</h1><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。<br><a id="more"></a></p><h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><p><a href="http://jsbin.com/piwohumoxa/edit?html,console,output" target="_blank" rel="noopener">代码演示地址</a><br>beforeCreate 在实例初始化之后调用，数据和事件都没绑定。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614112537.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>所以在beforeCreate访问不到任何东西。<br>created 在实例创建完成后被立即调用。数据和事件已经绑定，但是模板没有渲染，$el属性不可见 。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614113214.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>在created数据和事件都可以访问了，就能打印出数据。<br>beforeMount 模板渲染前调用<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614114126.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>beforeMount的时候可以访问到 $el 但是并没有渲染到页面上（virtual DOM）数据也还是这样的格式，所以不能操作DOM。<br>mounted 模板渲染到页面上调用<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614114126.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>mounted 的时候就可以操作dom，可以把dom操作放到这个生命周期。<br>beforeUpdate 数据更新时调用，发生在虚拟 DOM 打补丁之前。<br>在控制台执行 vm.lanpangzhi = 3<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614130548.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>beforeUpdate 这个钩子函数可以访问更新前的dom元素。这里的dom元素并没有更新掉。<br>updated 数据更新完触发。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614132057.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。<br>beforeDestroy 实例销毁之前调用。<br>在控制台执行 vm.$destroy()<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614132548.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>当这个钩子被调用时实例还可以用。<br>destroyed 实例销毁后调用。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614132830.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>created （实例创建完） 这个钩子函数可以用来请求数据发ajax。<br>mounted （模板渲染完） 这个钩子函数可以用来操作dom一些方法，如果你用了jQuery需要把代码放到这个钩子函数里面。<br>beforeUpdate （数据更新完） 这个钩子函数通常最好使用计算属性或 watcher 取而代之。<br>destroyed （实例销毁之前调用） 这个钩子函数触发的时候可以用来清理定时器变量。<br>还有几个钩子函数没有说到，建议自行去官网查看。</p><h2 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/vue2.0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/QQ%E5%9B%BE%E7%89%8720180614101803.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><p>在挂载开始之前被调用：相关的 render 函数首次被调用。<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。<br>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。<br>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</p><h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。<br>注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><p>实例销毁之前调用。在这一步，实例仍然完全可用。<br>该钩子在服务器端渲染期间不被调用。</p><h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。<br>该钩子在服务器端渲染期间不被调用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://cn.vuejs.org/v2/api/#beforeCreate" target="_blank" rel="noopener">https://cn.vuejs.org/v2/api/#beforeCreate</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;vue2-0的生命周期&quot;&gt;&lt;a href=&quot;#vue2-0的生命周期&quot; class=&quot;headerlink&quot; title=&quot;vue2.0的生命周期&quot;&gt;&lt;/a&gt;vue2.0的生命周期&lt;/h1&gt;&lt;p&gt;每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。&lt;br&gt;
    
    </summary>
    
    
      <category term="vue2.0" scheme="http://blog.langpz.com/tags/vue2-0/"/>
    
      <category term="生命周期" scheme="http://blog.langpz.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>webpack4.0入门指南（二）转换es7语法解析静态资源</title>
    <link href="http://blog.langpz.com/webpack4-0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BD%AC%E6%8D%A2es7%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90.html"/>
    <id>http://blog.langpz.com/webpack4-0入门指南（二）转换es7语法解析静态资源.html</id>
    <published>2018-06-13T13:30:47.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack4-0入门指南（二）转换es7语法解析静态资源"><a href="#webpack4-0入门指南（二）转换es7语法解析静态资源" class="headerlink" title="webpack4.0入门指南（二）转换es7语法解析静态资源"></a>webpack4.0入门指南（二）转换es7语法解析静态资源</h1><p>之前写了怎么转换es6的语法，如果在项目中用了es7的语法和样式，图片，字体该如何配置，下面就写一下配置。<br><a id="more"></a></p><h2 id="转换es7语法"><a href="#转换es7语法" class="headerlink" title="转换es7语法"></a>转换es7语法</h2><p>把之前demo3文件夹一份命名为demo4。<br>修改demo4/src/index.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;name: &apos;lanpangzhi&apos;&#125;;</span><br><span class="line">let obj2 = &#123;blog: &apos;http://blog.langpz.com&apos;&#125;;</span><br><span class="line">let newObj = &#123;...obj, ...obj2&#125;;  // es7语法</span><br><span class="line">console.log(newObj);</span><br></pre></td></tr></table></figure></p><p>安装babel插件，在项目根目录执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-preset-stage-0 -D  // ES7不同阶段语法提案的转码规则（共有4个阶段）</span><br></pre></td></tr></table></figure></p><p>stage-0 包含 stage-1 stage-2 stage-3 阶段 还包含 babel-plugin-transform-do-expressionsbabel-plugin-transform-function-bind 两个插件的功能，<a href="https://github.com/tc39/proposals" target="_blank" rel="noopener">阶段标准</a></p><p>修改demo4/.babelrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;,&quot;stage-0&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在demo4路径下执行 webpack，就看到打包成功了打开demo4/index.js文件控制台就输出。<br>{name: “lanpangzhi”, blog: “<a href="http://blog.langpz.com&quot;}">http://blog.langpz.com&quot;}</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180613143713.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="解析CSS"><a href="#解析CSS" class="headerlink" title="解析CSS"></a>解析CSS</h2><p>为了从 JavaScript 模块中 import 一个 CSS 文件，你需要配置如下loader。<br>安装babel插件，在项目根目录执行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure></p><p>修改demo4/webpack.config.js文件  在rules数组里添加一个规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.css$/, // 匹配所有.css结尾的文件</span><br><span class="line">  use: [ // use要从右往左写，先转成样式，再打包到style标签</span><br><span class="line">    &apos;style-loader&apos;,</span><br><span class="line">    &apos;css-loader&apos;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建css文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd src &amp;&amp; touch index.css</span><br></pre></td></tr></table></figure></p><p>修改demo4/src/index.css文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引入css文件<br>修改demo4/src/index.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 最上面添加一行</span><br><span class="line">import &apos;./index.css&apos;;</span><br></pre></td></tr></table></figure></p><p>在demo4路径下执行 webpack，就看到打包成功。打开demo4/index.html就有红色的背景色了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180613160924.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="解析sass"><a href="#解析sass" class="headerlink" title="解析sass"></a>解析sass</h2><p>为了从 JavaScript 模块中 import 一个 scss 文件，你需要配置如下loader。<br>安装babel插件，在项目根目录执行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader node-sass webpack --save-dev</span><br></pre></td></tr></table></figure></p><p>修改demo4/webpack.config.js文件，在rules数组里添加一个规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.scss$/, // 匹配所有.scss结尾的文件</span><br><span class="line">  use: [ </span><br><span class="line">    &apos;style-loader&apos;, // 将 JS 字符串生成为 style 节点</span><br><span class="line">    &apos;css-loader&apos;, // 将 CSS 转化成 CommonJS 模块</span><br><span class="line">    &apos;sass-loader&apos; // 将 Sass 编译成 CSS</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建scss文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd src &amp;&amp; touch index.scss</span><br></pre></td></tr></table></figure></p><p>修改demo4/src/index.scss文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$body-color: yellow;</span><br><span class="line">body &#123;</span><br><span class="line">  background: $body-color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改demo4/src/index.js文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 最上面一行替换如下代码</span><br><span class="line">import &apos;./index.scss&apos;;</span><br></pre></td></tr></table></figure></p><p>在demo4路径下执行 webpack，就看到sass编译成功。打开demo4/index.html就有绿色的背景色了。<br>!()[<a href="http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180613163909.png" target="_blank" rel="noopener">http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180613163909.png</a>]<br>如果你想解析其他预处理css语言安装对应loader，添加规则就可以编译了。<br>如less  less-loader。</p><h2 id="解析图片"><a href="#解析图片" class="headerlink" title="解析图片"></a>解析图片</h2><p>假想，现在我们正在下载 CSS，但是我们的背景和图标这些图片，要如何处理呢？使用 file-loader，我们可以轻松地将这些内容混合到 CSS 中。<br>安装babel插件，在项目根目录执行命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure></p><p>随意再网上下载一个png图片放到demo4/src/目录下，命名为1.png</p><p>修改demo4/src/index.scss文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  background: url(./1.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改demo4/webpack.config.js文件，在rules数组里添加一个规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(png|svg|jpg|gif)$/, // 匹配所有.png和.svg和.jpg和.gif结尾的文件</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &apos;file-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        publicPath: &apos;dist/&apos; // 设置public 发布目录。</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在demo4路径下执行 webpack，就看到图片编译成功。打开demo4/index.html就有背景图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180613171021.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="加载字体"><a href="#加载字体" class="headerlink" title="加载字体"></a>加载字体</h2><p>像字体这样的其他资源如何处理呢？file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。这就是说，我们可以将它们用于任何类型的文件，包括字体。让我们更新 webpack.config.js 来处理字体文件。<br>修改demo4/webpack.config.js文件，在rules数组里添加一个规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> test: /\.(woff|woff2|eot|ttf|otf)$/,</span><br><span class="line"> use: [</span><br><span class="line">   &apos;file-loader&apos;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果样式文件里面引入了字体就会被打包，这里就不演示了。</p><h1 id="demo仓库地址"><a href="#demo仓库地址" class="headerlink" title="demo仓库地址"></a>demo仓库地址</h1><p><a href="https://github.com/lanpangzhi/webpack-demo" target="_blank" rel="noopener">https://github.com/lanpangzhi/webpack-demo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack4-0入门指南（二）转换es7语法解析静态资源&quot;&gt;&lt;a href=&quot;#webpack4-0入门指南（二）转换es7语法解析静态资源&quot; class=&quot;headerlink&quot; title=&quot;webpack4.0入门指南（二）转换es7语法解析静态资源&quot;&gt;&lt;/a&gt;webpack4.0入门指南（二）转换es7语法解析静态资源&lt;/h1&gt;&lt;p&gt;之前写了怎么转换es6的语法，如果在项目中用了es7的语法和样式，图片，字体该如何配置，下面就写一下配置。&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://blog.langpz.com/tags/webpack/"/>
    
      <category term="打包工具" scheme="http://blog.langpz.com/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>yarn使用介绍</title>
    <link href="http://blog.langpz.com/yarn%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://blog.langpz.com/yarn使用介绍.html</id>
    <published>2018-06-12T14:19:09.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yarn使用介绍"><a href="#yarn使用介绍" class="headerlink" title="yarn使用介绍"></a>yarn使用介绍</h1><p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。Yarn要比npm要快一些，而且还更稳定，而且和npm使用相同的软件包流程也一样，下面只介绍一些常用的方法。尽快从npm上手yarn。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g yarn</span><br></pre></td></tr></table></figure><h2 id="初始化新项目"><a href="#初始化新项目" class="headerlink" title="初始化新项目"></a>初始化新项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br></pre></td></tr></table></figure><p>等同于 npm init， -y参数也是一样。</p><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h2><p>安装全局包需要先执行yarn global bin 然后把获取到的路径添加到环境变量path里面，感觉很麻烦也可以用 npm i -g 安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add create-react-app  // 全局安装等同于 npm i -g create-react-app</span><br></pre></td></tr></table></figure></p><p>安装包信息将加入到dependencies（生产阶段的依赖）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add forever   // 等同于 npm install forever -S </span><br><span class="line">yarn add forever@2.0.0 // 安装2.0.0版本</span><br></pre></td></tr></table></figure></p><p>将依赖项添加到不同依赖项类别<br>分别添加到 devDependencies、peerDependencies 和 optionalDependencies<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add express --dev  // 等同于 npm install forever -D </span><br><span class="line">yarn add express --peer</span><br><span class="line">yarn add express --optional</span><br></pre></td></tr></table></figure></p><p>peerDependencies “同伴依赖”，一种特殊的依赖，在发布包的时候需要。<br>有这种依赖意味着安装包的用户也需要和包同样的依赖。 这对于像 react 这样也被人安装的、需要单一 react-dom 副本的包很有用。<br>optionalDependencies 这是可选依赖，意味着依赖是……可选的。这种依赖即便安装失败，Yarn也会认为整个依赖安装过程是成功的。</p><h2 id="升级包"><a href="#升级包" class="headerlink" title="升级包"></a>升级包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn upgrade express  // 等同于 npm update express</span><br><span class="line">yarn global upgrade express // 等同于 npm update npm update express -g</span><br></pre></td></tr></table></figure><h2 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn remove express // 等同于 npm uninstall express</span><br><span class="line">yarn global remove express // 等同于 npm uninstall -g express</span><br></pre></td></tr></table></figure><h2 id="安装项目的全部依赖"><a href="#安装项目的全部依赖" class="headerlink" title="安装项目的全部依赖"></a>安装项目的全部依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn or yarn install  // 等同于 npm install</span><br></pre></td></tr></table></figure><h2 id="查看包安装信息"><a href="#查看包安装信息" class="headerlink" title="查看包安装信息"></a>查看包安装信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn list  // 等同于 npm list</span><br><span class="line">yarn global list  // npm list -g</span><br></pre></td></tr></table></figure><p>上面就是比较常用的方法了，可以快速从npm切换到yarn上，更多方法可以去官网查看。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">https://yarnpkg.com/zh-Hans/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;yarn使用介绍&quot;&gt;&lt;a href=&quot;#yarn使用介绍&quot; class=&quot;headerlink&quot; title=&quot;yarn使用介绍&quot;&gt;&lt;/a&gt;yarn使用介绍&lt;/h1&gt;&lt;p&gt;Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。Yarn要比npm要快一些，而且还更稳定，而且和npm使用相同的软件包流程也一样，下面只介绍一些常用的方法。尽快从npm上手yarn。&lt;br&gt;
    
    </summary>
    
    
      <category term="yarn" scheme="http://blog.langpz.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>webpack4.0入门指南（一）安装和转换es6语法</title>
    <link href="http://blog.langpz.com/webpack%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.html"/>
    <id>http://blog.langpz.com/webpack入门指南.html</id>
    <published>2018-06-08T10:35:24.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack4-0入门指南（一）安装和转换es6语法"><a href="#webpack4-0入门指南（一）安装和转换es6语法" class="headerlink" title="webpack4.0入门指南（一）安装和转换es6语法"></a>webpack4.0入门指南（一）安装和转换es6语法</h1><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack v4.0.0 开始，可以不用引入一个配置文件。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br><span class="line">npm install -g webpack-cli</span><br></pre></td></tr></table></figure><p>需要先全局安装你才可以使用webpack命令，然后再安装到你的项目依赖。<br>如果你使用 webpack 4+ 版本，你还需要安装 CLI。</p><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-demo &amp;&amp; cd webpack-demo  //创建并进入webpack-demo文件夹</span><br><span class="line">npm init -y   // 初始化项目package.json文件</span><br><span class="line">npm install -D webpack webpack-cli  // 本地安装 webpack和webpack-cli</span><br></pre></td></tr></table></figure><h2 id="使用默认配置去构建"><a href="#使用默认配置去构建" class="headerlink" title="使用默认配置去构建"></a>使用默认配置去构建</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir demo1 &amp;&amp; cd demo1</span><br><span class="line">touch index.html</span><br><span class="line">mkdir src &amp;&amp; cd src</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure><p>index.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--  webpack会把src/index.js文件打包到dist目录mian.js --&gt;</span><br><span class="line">  &lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>src/index.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure></p><p>执行 webpack 命令。就可以看到文件被打包到dist文件夹了。打开index.html文件就会弹出1。<br>webpack4.0可以不用写配置文件，然而大多数项目会需要很复杂的设置，需要你自己去配置。</p><h2 id="使用配置文件"><a href="#使用配置文件" class="headerlink" title="使用配置文件"></a>使用配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd .. // 返回到webpack-demo文件夹</span><br><span class="line">touch webpack.config.js  // 创建配置文件</span><br><span class="line">touch index.html</span><br><span class="line">mkdir demo2 &amp;&amp; cd demo2  // 创建demo2文件夹</span><br><span class="line">mkdir src &amp;&amp; cd src</span><br><span class="line">touch index.js</span><br></pre></td></tr></table></figure><p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,  // 入口文件</span><br><span class="line">  output: &#123;  // 出口文件</span><br><span class="line">    filename: &apos;bundle.js&apos;,   // 打包后命名为bundle.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;) // 输出的路径</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在项目的demo2目录执行webpack。如下图就代表打包成功。打开demo2下面的index.html 就可以弹出我的博客地址。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180608132222.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="使用babel转换es6语法-gt-es5"><a href="#使用babel转换es6语法-gt-es5" class="headerlink" title="使用babel转换es6语法 =&gt; es5"></a>使用babel转换es6语法 =&gt; es5</h2><h3 id="安装babel"><a href="#安装babel" class="headerlink" title="安装babel"></a>安装babel</h3><p>在webpack-demo路径下执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure></p><p>把demo2复制一份命名为demo3，在src目录下再新建a.js。<br>src/a.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default lanpangzhi = &quot;blog.langpz.com&quot;;</span><br></pre></td></tr></table></figure></p><p>src/index.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import lanpz from &quot;./a.js&quot;;</span><br><span class="line">console.log(lanpz);</span><br></pre></td></tr></table></figure></p><p>webpack.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;./src/index.js&apos;,  // 入口文件</span><br><span class="line">  output: &#123;  // 出口文件</span><br><span class="line">    filename: &apos;bundle.js&apos;,   // 打包后命名为bundle.js</span><br><span class="line">    path: path.resolve(__dirname, &apos;dist&apos;) // 输出的路径</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/, // 匹配所有.js结尾的文件</span><br><span class="line">        exclude: /node_modules/,  // 忽略node_modules文件夹</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &apos;babel-loader&apos;  // 使用babel-loader转义</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>新建 .babelrc 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch .babelrc</span><br></pre></td></tr></table></figure></p><p>.babelrc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行webpack就可以看见打包成功了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180608145725.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h3><p>由于 Babel 只转换语法(如箭头函数)， 你可以使用 babel-polyfill 支持新的全局变量，例如 Promise 、新的原生方法如 String.padStart (left-pad) 等。<br>在webpack-demo路径下执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save babel-polyfill  // 安装babel-polyfill</span><br></pre></td></tr></table></figure></p><p>在 webpack.config.js 中，将 babel-polyfill 加到你的 entry 数组中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: [&quot;babel-polyfill&quot;, &quot;./src/index.js&quot;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>执行webpack命令，如下图就成功了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/webpack4.0%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/QQ%E5%9B%BE%E7%89%8720180608151354.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="demo仓库地址"><a href="#demo仓库地址" class="headerlink" title="demo仓库地址"></a>demo仓库地址</h1><p><a href="https://github.com/lanpangzhi/webpack-demo" target="_blank" rel="noopener">https://github.com/lanpangzhi/webpack-demo</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.babeljs.cn/" target="_blank" rel="noopener">https://www.babeljs.cn/</a><br><a href="https://webpack.docschina.org/" target="_blank" rel="noopener">https://webpack.docschina.org/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack4-0入门指南（一）安装和转换es6语法&quot;&gt;&lt;a href=&quot;#webpack4-0入门指南（一）安装和转换es6语法&quot; class=&quot;headerlink&quot; title=&quot;webpack4.0入门指南（一）安装和转换es6语法&quot;&gt;&lt;/a&gt;webpack4.0入门指南（一）安装和转换es6语法&lt;/h1&gt;&lt;p&gt;webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 webpack v4.0.0 开始，可以不用引入一个配置文件。&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://blog.langpz.com/tags/webpack/"/>
    
      <category term="打包工具" scheme="http://blog.langpz.com/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>部署小说api服务到腾讯云</title>
    <link href="http://blog.langpz.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91.html"/>
    <id>http://blog.langpz.com/部署小说api服务到腾讯云.html</id>
    <published>2018-05-29T11:00:08.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="部署小说api服务到腾讯云"><a href="#部署小说api服务到腾讯云" class="headerlink" title="部署小说api服务到腾讯云"></a>部署小说api服务到腾讯云</h1><p>小说api1.0版本写完了，接下来就开始部署到服务器上，用到了nginx、pm2、nvm、git、OpenSSL。<br><a id="more"></a><br>服务器配置: CentOS 7.4 64位 1 核 2 GB 1 Mbps<br>node版本: 8.9.0<br>nvm版本: 0.33.11<br>npm版本： 5.5.1<br>nginx版本：1.12.2<br>git版本: 2.9.5</p><h2 id="第一步添加pm2配置文件"><a href="#第一步添加pm2配置文件" class="headerlink" title="第一步添加pm2配置文件"></a>第一步添加pm2配置文件</h2><p>在小说api项目的根目录创建一个pm2.json的文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;novel-api&quot;,  // 服务名</span><br><span class="line">    &quot;script&quot;: &quot;./bin/www&quot;, // 启动脚本</span><br><span class="line">    &quot;cwd&quot;: &quot;./&quot;,   // 当前工作路径</span><br><span class="line">    &quot;watch&quot;: [  // 监控变化的目录，一旦变化，自动重启</span><br><span class="line">        &quot;bin&quot;,</span><br><span class="line">        &quot;routers&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;ignore_watch&quot;: [  // 从监控目录中排除</span><br><span class="line">        &quot;node_modules&quot;,</span><br><span class="line">        &quot;logs&quot;,</span><br><span class="line">        &quot;public&quot;,</span><br><span class="line">        &quot;log&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;watch_options&quot;: &#123;</span><br><span class="line">        &quot;followSymlinks&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_memory_restart&quot;: &quot;1G&quot;, // 根据内存限制重新启动应用程序。</span><br><span class="line">    &quot;error_file&quot;: &quot;./logs/novel-apierr.log&quot;,  // 错误日志路径</span><br><span class="line">    &quot;out_file&quot;: &quot;./logs/novel-api-out.log&quot;,   // 普通日志路径</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;DEBUG&quot;: &quot;novel-api&quot;,  // 环境变量参数，debug名字为novel-api，8080端口监听</span><br><span class="line">        &quot;PORT&quot;: &quot;8080&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>package.json文件添加npm run deploy部署命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;deploy&quot;: &quot;pm2 start pm2.json&quot;</span><br></pre></td></tr></table></figure></p><p>pm2 常用命令。<br>pm2 save  保存当前进程列表。<br>pm2 resurrect  启动之前保存的进程列表。<br>pm2 restart app.js|app_name 重启进程<br>pm2 start app.js  启动进程<br>pm2 list 查看进程列表<br>pm2 stop app_name |app_id 停止指定的应用。 all 停止所有应用</p><h2 id="第二步购买服务器和域名"><a href="#第二步购买服务器和域名" class="headerlink" title="第二步购买服务器和域名"></a>第二步购买服务器和域名</h2><p>购买服务器<a href="https://buy.cloud.tencent.com/cvm?tab=lite" target="_blank" rel="noopener">https://buy.cloud.tencent.com/cvm?tab=lite</a>，我买的是CentOS 7.4 64位 1 核 2 GB 1 Mbps的服务器。如果只是尝试部署流程，可以选择按时计费。<br>购买域名<a href="https://dnspod.cloud.tencent.com/?from=qcloudProductDns" target="_blank" rel="noopener">https://dnspod.cloud.tencent.com/?from=qcloudProductDns</a>建议选.com的域名。</p><h2 id="第三步设置子域名"><a href="#第三步设置子域名" class="headerlink" title="第三步设置子域名"></a>第三步设置子域名</h2><p>添加一个api开头的子域名<a href="https://console.cloud.tencent.com/domain" target="_blank" rel="noopener">https://console.cloud.tencent.com/domain</a>，然后添加解析。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529113617.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="第四步登陆服务器安装软件"><a href="#第四步登陆服务器安装软件" class="headerlink" title="第四步登陆服务器安装软件"></a>第四步登陆服务器安装软件</h2><p>登陆到服务器然后执行以下安装命令。</p><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y nginx</span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure><h3 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span><br><span class="line">nvm --version</span><br></pre></td></tr></table></figure><h3 id="安装node和pm2、apidoc"><a href="#安装node和pm2、apidoc" class="headerlink" title="安装node和pm2、apidoc"></a>安装node和pm2、apidoc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nvm install 8.9.0</span><br><span class="line">nvm use 8.9.0</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">npm install -g pm2 apidoc</span><br></pre></td></tr></table></figure><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel tar</span><br><span class="line">yum install -y gcc-c++ perl-ExtUtils-MakeMaker</span><br><span class="line">cd /usr/src</span><br><span class="line">wget https://www.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz</span><br><span class="line">tar xf git-2.9.5.tar.gz</span><br><span class="line">cd git-2.9.5</span><br><span class="line">make configure</span><br><span class="line">make profix=/usr/git</span><br><span class="line">make install</span><br><span class="line">echo &quot;export PATH=$PATH:/usr/git/bin&quot; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br><span class="line">git --version </span><br><span class="line">// 配置git</span><br><span class="line">git config --global user.name &quot;用户名称&quot;</span><br><span class="line">git config --global user.email 电子邮件地址</span><br></pre></td></tr></table></figure><h2 id="在服务器上克隆git仓库"><a href="#在服务器上克隆git仓库" class="headerlink" title="在服务器上克隆git仓库"></a>在服务器上克隆git仓库</h2><p>先进入home路径创建wwwroot文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /home &amp;&amp; mkdir wwwroot</span><br><span class="line">cd wwwroot</span><br><span class="line">git clone https://github.com/lanpangzhi/novel-api.git</span><br><span class="line">cd novel-api</span><br><span class="line">npm install</span><br><span class="line">npm run doc</span><br><span class="line">npm run deploy</span><br></pre></td></tr></table></figure></p><p>这个应用就pm2被启动了。</p><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>先启动nginx。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></p><p><a href="http://123.206.45.87" target="_blank" rel="noopener">http://123.206.45.87</a> 在浏览器输入服务器ip就可以看到nginx已经启动了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529134733.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>进入nginx配置目录，新建文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/conf.d</span><br><span class="line">touch api.langpz.com-8080.conf</span><br></pre></td></tr></table></figure></p><p>如果一台服务器的server比较多，建议用域名和端口做配置文件名。<br>编辑api.langpz.com-8080.conf 配置文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi api.langpz.com-8080.conf</span><br></pre></td></tr></table></figure></p><p>把下面代码复制粘贴过去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">upstream novel-api &#123;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 你自己的域名;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://novel-api;</span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header   Host             $http_host;</span><br><span class="line">        proxy_set_header   X-NginX-Proxy    true;</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ctrl + c 输入:wq  退出并保存。再执行nginx -s reload 在浏览器输入你的域名就可以看到文档，<a href="http://api.langpz.com" target="_blank" rel="noopener">http://api.langpz.com</a></p><h3 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/</span><br><span class="line">vi nginx.conf</span><br></pre></td></tr></table></figure><p>把下面代码复制粘贴过去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">## gzip压缩</span><br><span class="line">gzip on;</span><br><span class="line"># ie6不启用gzip</span><br><span class="line">gzip_disable &quot;msie6&quot;;</span><br><span class="line">gzip_vary on;</span><br><span class="line">gzip_proxied any;</span><br><span class="line"># 压缩等级 1-9</span><br><span class="line">gzip_comp_level 2;</span><br><span class="line">gzip_buffers 16 8k;</span><br><span class="line">gzip_http_version 1.1;</span><br><span class="line"># 为除“text/html”之外的MIME类型启用压缩</span><br><span class="line">gzip_types text/plain text/css application/json application/x-javascript image/gif image/jpeg image/png image/tiff image/x-icon application/font-woff application/vnd.ms-fontobject text/javascript;</span><br></pre></td></tr></table></figure></p><p>ctrl + c 输入:wq  退出并保存。再执行nginx -s reload。可以去站长之家看你的压缩率<a href="http://tool.chinaz.com/gzips/" target="_blank" rel="noopener">http://tool.chinaz.com/gzips/</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529140415.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h3 id="隐藏nginx版本号"><a href="#隐藏nginx版本号" class="headerlink" title="隐藏nginx版本号"></a>隐藏nginx版本号</h3><p>还是修改nginx.conf这个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi nginx.conf</span><br><span class="line"></span><br><span class="line">// 把下面代码复制过去</span><br><span class="line"># 隐藏nginx版本号</span><br><span class="line">server_tokens off;</span><br></pre></td></tr></table></figure></p><p>ctrl + c 输入:wq  退出并保存。再执行nginx -s reload。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529140928.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>这里就不显示nginx版本号了。</p><h3 id="配置ssl证书https，给你的网站加个小绿锁"><a href="#配置ssl证书https，给你的网站加个小绿锁" class="headerlink" title="配置ssl证书https，给你的网站加个小绿锁"></a>配置ssl证书https，给你的网站加个小绿锁</h3><p>我用的是腾讯云的免费证书，也可以自己生成。<a href="https://cloud.tencent.com/product/ssl?from=qcloudHpHeaderSsl" target="_blank" rel="noopener">https://cloud.tencent.com/product/ssl?from=qcloudHpHeaderSsl</a>，使用域名免费版。</p><h4 id="申请腾讯云ssl证书"><a href="#申请腾讯云ssl证书" class="headerlink" title="申请腾讯云ssl证书"></a>申请腾讯云ssl证书</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529141439.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>直接点下一步，然后用推荐选项验证。申请很快不到十分钟就下来，到时候还会有邮件和短信通知。</p><h4 id="下载证书上传到服务器"><a href="#下载证书上传到服务器" class="headerlink" title="下载证书上传到服务器"></a>下载证书上传到服务器</h4><p>找到腾讯云的ssl证书管理去下载证书。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529142105.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>压缩包里面有三个文件夹找到Nginx这个文件夹。<br>在服务器进入nginx所在目录新建一个文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/</span><br><span class="line">mkdir api.langpz.com</span><br></pre></td></tr></table></figure></p><p>然后把Nginx文件夹里面两个文件上传到服务器/etc/nginx/api.langpz.com 这个文件夹里面。<br>可以下载一个FileZilla软件或者下载一个别的ftp工具，还可以用命令行，我这里下载了FileZilla使用它去上传。</p><h4 id="加强-HTTPS-安全性"><a href="#加强-HTTPS-安全性" class="headerlink" title="加强 HTTPS 安全性"></a>加强 HTTPS 安全性</h4><p>首先在目录 /etc/nginx/api.langpz.com 运行以下代码生成 dhparam.pem 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/api.langpz.com</span><br><span class="line">openssl dhparam -out dhparam.pem 2048</span><br></pre></td></tr></table></figure></p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/conf.d</span><br><span class="line">touch api.langpz.com-8080.conf</span><br></pre></td></tr></table></figure><p>把下面代码覆盖api.langpz.com-8080.conf文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">upstream novel-api &#123;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 配置共享会话缓存大小</span><br><span class="line">ssl_session_cache shared:SSL:10m;</span><br><span class="line"># 配置会话超时时间</span><br><span class="line">ssl_session_timeout 10m;</span><br><span class="line"></span><br><span class="line"># 强制跳转https</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name api.langpz.com;</span><br><span class="line">    return 301 https://$server_name$request_uri;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"> listen 443 ssl;</span><br><span class="line"> server_name api.langpz.com;</span><br><span class="line"></span><br><span class="line"> # 证书文件</span><br><span class="line"> ssl_certificate      /etc/nginx/api.langpz.com/1_api.langpz.com_bundle.crt;</span><br><span class="line"> # 私钥文件</span><br><span class="line"> ssl_certificate_key  /etc/nginx/api.langpz.com/2_api.langpz.com.key;</span><br><span class="line"> # 设置长连接</span><br><span class="line"> keepalive_timeout    70;</span><br><span class="line"> # 优先采取服务器算法</span><br><span class="line"> ssl_prefer_server_ciphers on;</span><br><span class="line"> # 使用DH文件</span><br><span class="line"> ssl_dhparam /etc/nginx/api.langpz.com/dhparam.pem;</span><br><span class="line"> ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line"> # 定义算法</span><br><span class="line"> ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;;</span><br><span class="line"> # HSTS策略</span><br><span class="line"> add_header Strict-Transport-Security &quot;max-age=31536000; includeSubDomains;preload&quot; always;</span><br><span class="line"> # 防XSS攻擊</span><br><span class="line"> add_header X-Xss-Protection 1;</span><br><span class="line"> # 禁止服务器自动解析资源类型</span><br><span class="line"> add_header X-Content-Type-Options nosniff;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> location / &#123;</span><br><span class="line">    proxy_pass http://novel-api;</span><br><span class="line">    proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">    proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header   Host             $http_host;</span><br><span class="line">    proxy_set_header   X-NginX-Proxy    true;</span><br><span class="line">    proxy_redirect     off;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ctrl + c 输入:wq  退出并保存。再执行nginx -s reload。<br>现在就可以访问<a href="https://api.langpz.com" target="_blank" rel="noopener">https://api.langpz.com</a>。如果访问http协议就会强制跳转到https协议。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529143306.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="SSL安全测试"><a href="#SSL安全测试" class="headerlink" title="SSL安全测试"></a>SSL安全测试</h2><p><a href="https://www.ssllabs.com/ssltest/index.html" target="_blank" rel="noopener"></a><br>输入你的域名。<br>之前在nginx配置加强 HTTPS 安全性，所以结果是A+。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AF%B4api%E6%9C%8D%E5%8A%A1%E5%88%B0%E8%85%BE%E8%AE%AF%E4%BA%91/QQ%E5%9B%BE%E7%89%8720180529143835.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这种部署比较麻烦，部署完发现pm2也有部署功能，2.0用koa.js重构的时候用pm2部署，docker 生成镜像。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://nginx.org/en/docs/" target="_blank" rel="noopener">https://nginx.org/en/docs/</a><br><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">https://github.com/creationix/nvm</a><br><a href="https://www.thinkjs.org/zh-cn/doc/3.0/deploy.html" target="_blank" rel="noopener">https://www.thinkjs.org/zh-cn/doc/3.0/deploy.html</a><br><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" target="_blank" rel="noopener">https://www.cnblogs.com/chyingp/p/pm2-documentation.html</a><br><a href="http://www.runoob.com/git/git-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-install-setup.html</a><br><a href="https://nginx.rails365.net/chapters/install.html" target="_blank" rel="noopener">https://nginx.rails365.net/chapters/install.html</a><br><a href="https://www.cnblogs.com/nuccch/p/7681592.html" target="_blank" rel="noopener">https://www.cnblogs.com/nuccch/p/7681592.html</a><br><a href="https://aotu.io/notes/2016/08/16/nginx-https/index.html" target="_blank" rel="noopener">https://aotu.io/notes/2016/08/16/nginx-https/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;部署小说api服务到腾讯云&quot;&gt;&lt;a href=&quot;#部署小说api服务到腾讯云&quot; class=&quot;headerlink&quot; title=&quot;部署小说api服务到腾讯云&quot;&gt;&lt;/a&gt;部署小说api服务到腾讯云&lt;/h1&gt;&lt;p&gt;小说api1.0版本写完了，接下来就开始部署到服务器上，用到了nginx、pm2、nvm、git、OpenSSL。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="API" scheme="http://blog.langpz.com/tags/API/"/>
    
      <category term="部署" scheme="http://blog.langpz.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>使用apidoc文档神器，快速生成api文档</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8apidoc%E6%96%87%E6%A1%A3%E7%A5%9E%E5%99%A8%EF%BC%8C%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90api%E6%96%87%E6%A1%A3.html"/>
    <id>http://blog.langpz.com/使用apidoc文档神器，快速生成api文档.html</id>
    <published>2018-05-26T11:13:37.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用apidoc文档神器，快速生成api文档"><a href="#使用apidoc文档神器，快速生成api文档" class="headerlink" title="使用apidoc文档神器，快速生成api文档"></a>使用apidoc文档神器，快速生成api文档</h1><p>写完api接口，就需要编写api文档了，如果一个个手写的话就很麻烦，就得使用apidoc只需要通过写注释，就可以快速生成文档了。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>第一步先安装全局模块apidoc。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install apidoc -g</span><br></pre></td></tr></table></figure></p><h2 id="修改接口的注释"><a href="#修改接口的注释" class="headerlink" title="修改接口的注释"></a>修改接口的注释</h2><p>找到novel-api项目routes下面的index.js文件，注释修改成如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @api &#123;get&#125; /index 请求首页数据</span><br><span class="line"> * @apiVersion 1.0.0</span><br><span class="line"> * @apiName 获取首页数据</span><br><span class="line"> * @apiGroup index</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @apiSuccess &#123;Number&#125; flag 是否获取到数据 1成功 0失败</span><br><span class="line"> * @apiSuccess &#123;Array&#125; books 返回书籍内容</span><br><span class="line"> * @apiSuccess &#123;String&#125; msg  返回信息</span><br><span class="line"> *</span><br><span class="line"> * @apiSuccessExample &#123;json&#125; Success-Response:</span><br><span class="line"> *     HTTP/1.1 200 OK</span><br><span class="line"> *    &#123;</span><br><span class="line"> *      &quot;flag&quot;: 1,</span><br><span class="line"> *      &quot;books&quot;: [</span><br><span class="line"> *          &#123;</span><br><span class="line"> *             &quot;_id&quot;: &quot;5816b415b06d1d32157790b1&quot;,</span><br><span class="line"> *            &quot;title&quot;: &quot;圣墟&quot;,</span><br><span class="line"> *            &quot;author&quot;: &quot;辰东&quot;,</span><br><span class="line"> *            &quot;shortIntro&quot;: &quot;在破败中崛起，在寂灭中复苏。沧海成尘，雷电枯竭，那一缕幽雾又一次临近大地，世间的枷锁被打开了，一个全新的世界就此揭开神秘的一角……&quot;,</span><br><span class="line"> *            &quot;cover&quot;: &quot;http://statics.zhuishushenqi.com/agent/http%3A%2F%2Fimg.1391.com%2Fapi%2Fv1%2Fbookcenter%2Fcover%2F1%2F1228859%2F1228859_fac7917a960547eb953edf0b740cef3a.jpg%2F&quot;,</span><br><span class="line"> *            &quot;site&quot;: &quot;zhuishuvip&quot;,</span><br><span class="line"> *            &quot;majorCate&quot;: &quot;玄幻&quot;,</span><br><span class="line"> *            &quot;minorCate&quot;: &quot;东方玄幻&quot;,</span><br><span class="line"> *            &quot;allowMonthly&quot;: false,</span><br><span class="line"> *            &quot;banned&quot;: 0,</span><br><span class="line"> *            &quot;latelyFollower&quot;: 283375,</span><br><span class="line"> *            &quot;retentionRatio&quot;: &quot;73.42&quot;</span><br><span class="line"> *          &#125;</span><br><span class="line"> *      ],</span><br><span class="line"> *      &quot;msg&quot;: &quot;OK&quot;</span><br><span class="line"> *    &#125;</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * @apiErrorExample Error-Response:</span><br><span class="line"> *     HTTP/1.1 404 Not Found</span><br><span class="line"> *     &#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;rankingId有问题&quot; &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p>@api {method} path [title]<br>@api 如果没有@api apidoc会忽略这段注释<br>method 请求的方法<br>path 路径<br>title 标题</p><p>@apiVersion version<br>设置文档块的版本。<br>version 版本号</p><p>@apiName name<br>定义方法文档块的名称。名称将用于生成的输出中的子导航。<br>name 方法的名称</p><p>@apiGroup name<br>定义方法文档块属于哪个组。组将用于生成的输出中的主导航。<br>name 组的名称。也用作导航标题。</p><p>@apiSuccess [(group)] [{type}] field [description]<br>成功返回参数。<br>(group) 可选 所有参数将按这个名称分组。没有组，默认Success 200设置。<br>{type} 可选 返回类型<br>field 返回标识符<br>description 描述</p><p>@apiParamExample [{type}] [title]<br>                   example<br>参数请求示例。<br>{type} 可选 响应格式<br>title 示例的简称<br>example 详细的例子</p><p>@apiErrorExample [{type}] [title]<br>                 example<br>错误返回消息的示例，输出为预格式化代码。<br>{type} 可选 响应格式<br>title 示例的简称<br>example 详细的例子</p><h2 id="配置npm-run-doc"><a href="#配置npm-run-doc" class="headerlink" title="配置npm run doc"></a>配置npm run doc</h2><p>打开package.json文件增加doc命令配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;doc&quot;: &quot;apidoc -i routes/ -o public/&quot;</span><br></pre></td></tr></table></figure></p><p>routes/ 要输出API文档的文件夹。<br>public/ 输出文档到public文件夹，没有回自动创建。<br>执行 npm run doc<br>访问 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 就可以看到生成好的API文档了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/apidoc/111.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/apidoc/apidoc" target="_blank" rel="noopener">https://github.com/apidoc/apidoc</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用apidoc文档神器，快速生成api文档&quot;&gt;&lt;a href=&quot;#使用apidoc文档神器，快速生成api文档&quot; class=&quot;headerlink&quot; title=&quot;使用apidoc文档神器，快速生成api文档&quot;&gt;&lt;/a&gt;使用apidoc文档神器，快速生成api文档&lt;/h1&gt;&lt;p&gt;写完api接口，就需要编写api文档了，如果一个个手写的话就很麻烦，就得使用apidoc只需要通过写注释，就可以快速生成文档了。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="API" scheme="http://blog.langpz.com/tags/API/"/>
    
      <category term="apidoc" scheme="http://blog.langpz.com/tags/apidoc/"/>
    
  </entry>
  
  <entry>
    <title>使用Express开发小说API接口服务1.0（三）</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8Express%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AF%B4API%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A11-0%EF%BC%88%E4%B8%89%EF%BC%89.html"/>
    <id>http://blog.langpz.com/使用Express开发小说API接口服务1-0（三）.html</id>
    <published>2018-05-26T10:54:41.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Express开发小说API接口服务1-0（三）"><a href="#使用Express开发小说API接口服务1-0（三）" class="headerlink" title="使用Express开发小说API接口服务1.0（三）"></a>使用Express开发小说API接口服务1.0（三）</h1><p>之前发现追书神器API详情页竟然没有下一章和上一章的返回值，只能自己动手封装一下。<br><a id="more"></a></p><h1 id="app-js-增加错误处理"><a href="#app-js-增加错误处理" class="headerlink" title="app.js 增加错误处理"></a>app.js 增加错误处理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// catch 404 and forward to error handler</span><br><span class="line">app.use(function (req, res, next) &#123;</span><br><span class="line">    const err = new Error(&apos;Not Found&apos;);</span><br><span class="line">    err.status = 404;</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// error handler</span><br><span class="line">app.use(function (err, req, res, next) &#123;</span><br><span class="line">    // set locals, only providing error in development</span><br><span class="line">    res.locals.message = err.message;</span><br><span class="line">    res.locals.error = req.app.get(&apos;env&apos;) === &apos;development&apos; ? err : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // render the error page</span><br><span class="line">    res.status(err.status || 500);</span><br><span class="line">    res.render(&apos;error&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这些代码放到module.exports = app; 上面就可以了。</p><h2 id="列表页增加返回ID"><a href="#列表页增加返回ID" class="headerlink" title="列表页增加返回ID"></a>列表页增加返回ID</h2><p>找到routes/chapter.js 29行替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.send(JSON.stringify(&#123; &quot;flag&quot;: 1,&quot;id&quot;: body._id,  &quot;chapters&quot;: body.chapters, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br></pre></td></tr></table></figure></p><h2 id="详情页增加上一章和下一章的返回值"><a href="#详情页增加上一章和下一章的返回值" class="headerlink" title="详情页增加上一章和下一章的返回值"></a>详情页增加上一章和下一章的返回值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let request = require(&apos;request&apos;);</span><br><span class="line">let common = require(&apos;../common/common.json&apos;); // 引用公共文件</span><br><span class="line">let router = express.Router();</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">  获取小说文章内容</span><br><span class="line">  返回小说文章内容</span><br><span class="line">  param link &#123;String&#125; 是小说文章列表接口 chapters[0].link</span><br><span class="line">  http://chapter2.zhuishushenqi.com/chapter/$&#123;link&#125;</span><br><span class="line">*/</span><br><span class="line">router.get(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">    if (!req.query.link) &#123;</span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入link...&quot; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    // req.query.link 编码转义</span><br><span class="line">    let link = encodeURIComponent(req.query.link);</span><br><span class="line">    request.get(`$&#123;common.CHAPTER&#125;/chapter/$&#123;link&#125;`, function (err, response, body) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解析返回的数据</span><br><span class="line">        body = JSON.parse(body);</span><br><span class="line"></span><br><span class="line">        if (body.ok)&#123;</span><br><span class="line">            // 再次请求列表页获取上一页和下一页</span><br><span class="line">            if(req.query.id)&#123;</span><br><span class="line">                // req.query.id 编码转义</span><br><span class="line">                let id = encodeURIComponent(req.query.id);</span><br><span class="line">                let n = parseInt(req.query.n);</span><br><span class="line">                if (isNaN(n))&#123;</span><br><span class="line">                    n = 0;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                request.get(`$&#123;common.API&#125;/atoc/$&#123;id&#125;?view=chapters`, function (err, response, body2) &#123;</span><br><span class="line">                    if (err) &#123;</span><br><span class="line">                        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (body2 == &quot;wrong param&quot;)&#123;</span><br><span class="line">                        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入错误的ID...&quot; &#125;));</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        // 解析返回的数据</span><br><span class="line">                        body2 = JSON.parse(body2);</span><br><span class="line">                        // 检查页码是否超过小说的章节数</span><br><span class="line">                        if(n &gt; body2.chapters.length - 1)&#123;</span><br><span class="line">                            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入的页码过大&quot; &#125;));</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            // 如果有上一页或者下一页就返回link否则返回false</span><br><span class="line">                            let prev,next;</span><br><span class="line">                            body2.chapters[n - 1] ? prev = body2.chapters[n - 1].link : prev = false;</span><br><span class="line">                            body2.chapters[n + 1] ? next = body2.chapters[n + 1].link : next = false;</span><br><span class="line"></span><br><span class="line">                            if (body2.chapters.length &gt; 0) &#123;</span><br><span class="line">                                res.send(JSON.stringify(&#123; &quot;flag&quot;: 1,&quot;id&quot;: id, &quot;chapter&quot;: body.chapter, &quot;prev&quot;: prev,&quot;next&quot;: next, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;chapter&quot;: body.chapter, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入link有错误&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037&amp;n=2648&amp;id=577b6c81ccb7bf00499d036c" target="_blank" rel="noopener">http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037&amp;n=2648&amp;id=577b6c81ccb7bf00499d036c</a><br>新增n和id参数。<br>n 代表是第几页。<br>id 是书籍ID。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用Express开发小说API接口服务1-0（三）&quot;&gt;&lt;a href=&quot;#使用Express开发小说API接口服务1-0（三）&quot; class=&quot;headerlink&quot; title=&quot;使用Express开发小说API接口服务1.0（三）&quot;&gt;&lt;/a&gt;使用Express开发小说API接口服务1.0（三）&lt;/h1&gt;&lt;p&gt;之前发现追书神器API详情页竟然没有下一章和上一章的返回值，只能自己动手封装一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="API" scheme="http://blog.langpz.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>使用Express开发小说API接口服务1.0(二)</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8Express%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AF%B4API%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1-%E4%BA%8C.html"/>
    <id>http://blog.langpz.com/使用Express开发小说API接口服务-二.html</id>
    <published>2018-05-18T13:26:05.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Express开发小说API接口服务1-0-二"><a href="#使用Express开发小说API接口服务1-0-二" class="headerlink" title="使用Express开发小说API接口服务1.0(二)"></a>使用Express开发小说API接口服务1.0(二)</h1><p>之前完成了首页和搜索的接口，现在就开始写剩下的接口。<br><a id="more"></a></p><h2 id="获取小说源"><a href="#获取小说源" class="headerlink" title="获取小说源"></a>获取小说源</h2><p>因为追书神器正版源是收费加密的，所以只能使用盗版源，所以要封装一个获取小说源的接口。<br>修改app.js 文件路由中间件配置，增加一个路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sourceRouter = require(&apos;./routes/source&apos;);</span><br><span class="line">app.use(&apos;/source&apos;, sourceRouter);</span><br></pre></td></tr></table></figure></p><p>在routes下面新建 source.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let request = require(&apos;request&apos;);</span><br><span class="line">let common = require(&apos;../common/common.json&apos;); // 引用公共文件</span><br><span class="line">let router = express.Router();</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">  获取小说源</span><br><span class="line">  返回盗版源和正版源</span><br><span class="line">  param id &#123;String&#125; 是首页和搜索返回接口 books[i].id</span><br><span class="line">  param n &#123;Number || String&#125;  使用第几个源，可以不用传参默认 1</span><br><span class="line">  http://api.zhuishushenqi.com/atoc?view=summary&amp;book=$&#123;bookID&#125;</span><br><span class="line">*/</span><br><span class="line">router.get(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">    if (!req.query.id) &#123;</span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入ID...&quot; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    // req.query.id 编码转义</span><br><span class="line">    let id = encodeURI(req.query.id);</span><br><span class="line">    request.get(`$&#123;common.API&#125;/atoc?view=summary&amp;book=$&#123;id&#125;`, function (err, response, body)&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 解析返回的数据</span><br><span class="line">        body = JSON.parse(body);</span><br><span class="line">        // 判断是否返回内容</span><br><span class="line">        if (body.length == 0)&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;没有获取到小说源，换个小说看吧&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 第一个源是正版源，是收费加密的，所以默认选中第二个源</span><br><span class="line">        let n = parseInt(req.query.n);</span><br><span class="line">        if (isNaN(n) || n == 0)&#123;</span><br><span class="line">            n = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 判断n是否大于源数据的长度</span><br><span class="line">        if (n &gt;= body.length)&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;n的参数值不正确，没有那个源&quot; &#125;));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;books&quot;: body[n], &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></p><p>访问<a href="http://localhost:3000/source/?id=50864bf69dacd30e3a000014&amp;n=3" target="_blank" rel="noopener">http://localhost:3000/source/?id=50864bf69dacd30e3a000014&amp;n=3</a> 就可以看到返回第四个源的数据。</p><h2 id="小说文章列表"><a href="#小说文章列表" class="headerlink" title="小说文章列表"></a>小说文章列表</h2><p>修改app.js 文件路由中间件配置，增加一个路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let chapterRouter = require(&apos;./routes/chapter&apos;);</span><br><span class="line">app.use(&apos;/chapter&apos;, chapterRouter);</span><br></pre></td></tr></table></figure></p><p>在routes下面新建 chapter.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let request = require(&apos;request&apos;);</span><br><span class="line">let common = require(&apos;../common/common.json&apos;); // 引用公共文件</span><br><span class="line">let router = express.Router();</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">  获取小说文章列表</span><br><span class="line">  返回小说文章列表</span><br><span class="line">  param id &#123;String&#125; 是小说源接口 books.id</span><br><span class="line">  http://api.zhuishushenqi.com/atoc/$&#123;id&#125;?view=chapters</span><br><span class="line">*/</span><br><span class="line">router.get(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">    if (!req.query.id)&#123;</span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入ID...&quot; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    // req.query.id 编码转义</span><br><span class="line">    let id = encodeURIComponent(req.query.id);</span><br><span class="line">    request.get(`$&#123;common.API&#125;/atoc/$&#123;id&#125;?view=chapters`, function (err, response, body) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (body == &quot;wrong param&quot;)&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入错误的ID...&quot; &#125;));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            // 解析返回的数据</span><br><span class="line">            body = JSON.parse(body);</span><br><span class="line">            if (body.chapters.length &gt; 0) &#123;</span><br><span class="line">                res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;chapters&quot;: body.chapters, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></p><p>访问<a href="http://localhost:3000/chapter/?id=57416370ccc94e4b41df80cc" target="_blank" rel="noopener">http://localhost:3000/chapter/?id=57416370ccc94e4b41df80cc</a> 就可以看到数据。id小说源接口返回的id。</p><h2 id="小说文章内容"><a href="#小说文章内容" class="headerlink" title="小说文章内容"></a>小说文章内容</h2><p>修改app.js 文件路由中间件配置，增加一个路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let articleRouter = require(&apos;./routes/article&apos;);</span><br><span class="line">app.use(&apos;/article&apos;, articleRouter);</span><br></pre></td></tr></table></figure></p><p>在routes下面新建 article.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let request = require(&apos;request&apos;);</span><br><span class="line">let common = require(&apos;../common/common.json&apos;); // 引用公共文件</span><br><span class="line">let router = express.Router();</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">  获取小说文章内容</span><br><span class="line">  返回小说文章内容</span><br><span class="line">  param link &#123;String&#125; 是小说文章列表接口 chapters[0].link</span><br><span class="line">  http://chapter2.zhuishushenqi.com/chapter/$&#123;link&#125;</span><br><span class="line">*/</span><br><span class="line">router.get(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">    if (!req.query.link) &#123;</span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入link...&quot; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    // req.query.link 编码转义</span><br><span class="line">    let link = encodeURIComponent(req.query.link);</span><br><span class="line">    request.get(`$&#123;common.CHAPTER&#125;/chapter/$&#123;link&#125;`, function (err, response, body) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解析返回的数据</span><br><span class="line">        body = JSON.parse(body);</span><br><span class="line"></span><br><span class="line">        if (body.ok)&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;chapter&quot;: body.chapter, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入link有错误&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></p><p>访问<a href="http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037" target="_blank" rel="noopener">http://localhost:3000/article?link=http://www.69shu.com/txt/1463/4861037</a> 就可以看到数据。</p><h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><p>修改app.js 文件路由中间件配置，增加一个路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let rankingRouter = require(&apos;./routes/ranking&apos;);</span><br><span class="line">app.use(&apos;/ranking&apos;, rankingRouter);</span><br></pre></td></tr></table></figure></p><p>在routes下面新建 ranking.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let request = require(&apos;request&apos;);</span><br><span class="line">let common = require(&apos;../common/common.json&apos;); // 引用公共文件</span><br><span class="line">let router = express.Router();</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">  获取排行榜</span><br><span class="line">  返回排行榜</span><br><span class="line">  param id &#123;String&#125; 没有传参数就是获取全部榜单，否则根据参数获取榜单</span><br><span class="line">  http://api.zhuishushenqi.com/ranking/gender</span><br><span class="line">  http://api.zhuishushenqi.com/ranking/$&#123;id&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;, function (req, res, next) &#123;</span><br><span class="line">    // 获取全部榜单</span><br><span class="line">    request.get(`$&#123;common.API&#125;/ranking/gender`, function (err, response, body) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 解析返回的数据</span><br><span class="line">        body = JSON.parse(body);</span><br><span class="line"></span><br><span class="line">        if (body.ok) &#123;</span><br><span class="line">            let ranking = &#123;</span><br><span class="line">                male: body.male,</span><br><span class="line">                picture: body.picture,</span><br><span class="line">                epub: body.epub,</span><br><span class="line">                female: body.female</span><br><span class="line">            &#125;;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;ranking&quot;: ranking, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;出错了&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(&apos;/:id&apos;, function (req, res, next) &#123;</span><br><span class="line">    if (req.params.id) &#123;</span><br><span class="line">        // req.param.id 编码转义</span><br><span class="line">        let id = encodeURIComponent(req.params.id);</span><br><span class="line"></span><br><span class="line">        // 根据id获取榜单</span><br><span class="line">        request.get(`$&#123;common.API&#125;/ranking/$&#123;id&#125;`, function (err, response, body) &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 解析返回的数据</span><br><span class="line">            body = JSON.parse(body);</span><br><span class="line"></span><br><span class="line">            if (body.ok) &#123;</span><br><span class="line">                res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;ranking&quot;: body.ranking, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;传入id错误&quot; &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;id没有传&quot; &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></p><p>分别访问<a href="http://localhost:3000/ranking/" target="_blank" rel="noopener">http://localhost:3000/ranking/</a> 和 <a href="http://localhost:3000/ranking/54d43437d47d13ff21cad58b" target="_blank" rel="noopener">http://localhost:3000/ranking/54d43437d47d13ff21cad58b</a> 就可以获取到榜单的数据。<br>1.0版本的开发就告于段落了。<br>github仓库访问地址<a href="https://github.com/lanpangzhi/novel-api" target="_blank" rel="noopener">https://github.com/lanpangzhi/novel-api</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/expressjs/morgan" target="_blank" rel="noopener">https://github.com/expressjs/morgan</a><br><a href="https://juejin.im/entry/593a3fdf61ff4b006c737ca4" target="_blank" rel="noopener">https://juejin.im/entry/593a3fdf61ff4b006c737ca4</a><br><a href="https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用Express开发小说API接口服务1-0-二&quot;&gt;&lt;a href=&quot;#使用Express开发小说API接口服务1-0-二&quot; class=&quot;headerlink&quot; title=&quot;使用Express开发小说API接口服务1.0(二)&quot;&gt;&lt;/a&gt;使用Express开发小说API接口服务1.0(二)&lt;/h1&gt;&lt;p&gt;之前完成了首页和搜索的接口，现在就开始写剩下的接口。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="API" scheme="http://blog.langpz.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>使用Express开发小说API接口服务1.0（一）</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8Express%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AF%B4API%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1.html"/>
    <id>http://blog.langpz.com/使用Express开发小说API接口服务.html</id>
    <published>2018-05-17T15:10:56.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用Express开发小说API接口服务1-0（一）"><a href="#使用Express开发小说API接口服务1-0（一）" class="headerlink" title="使用Express开发小说API接口服务1.0（一）"></a>使用Express开发小说API接口服务1.0（一）</h1><p>1.0版本技术栈使用express-generator、express、request、morgan、file-stream-rotator。接口用追书神器API。<br>目前接口设计有首页，小说详情页，搜索，小说文章列表页，排行API。<br><a id="more"></a></p><h2 id="github创建仓库"><a href="#github创建仓库" class="headerlink" title="github创建仓库"></a>github创建仓库</h2><p>先创建一个仓库放文件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8Express%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AF%B4API%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1/QQ%E5%9B%BE%E7%89%8720180517153417.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后克隆创建好的仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lanpangzhi/novel-api.git</span><br></pre></td></tr></table></figure></p><h2 id="安装-express-generator-快速生成项目"><a href="#安装-express-generator-快速生成项目" class="headerlink" title="安装 express-generator 快速生成项目"></a>安装 express-generator 快速生成项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g express-generator</span><br></pre></td></tr></table></figure><p>然后再之前克隆仓库的上一级目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">express --no-view novel-api</span><br><span class="line">cd novel-api</span><br><span class="line">npm install </span><br><span class="line">npm install request file-stream-rotator -S</span><br><span class="line">// Linux MacOS</span><br><span class="line">DEBUG=novel-api:* &amp; npm start</span><br><span class="line">// windows </span><br><span class="line">set DEBUG=novel-api:* &amp; npm start</span><br></pre></td></tr></table></figure></p><p>生成好的目录结构和文件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8Express%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AF%B4API%E6%8E%A5%E5%8F%A3%E6%9C%8D%E5%8A%A1/QQ%E5%9B%BE%E7%89%8720180517154349.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="设置cors-跨域"><a href="#设置cors-跨域" class="headerlink" title="设置cors 跨域"></a>设置cors 跨域</h2><p>打开项目根目录app.js,放在路由上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.all(&apos;*&apos;, function (req, res, next) &#123;</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;);</span><br><span class="line">    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">    res.header(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;)</span><br><span class="line">    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);</span><br><span class="line">    next()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="日志写入本地文件"><a href="#日志写入本地文件" class="headerlink" title="日志写入本地文件"></a>日志写入本地文件</h2><p>按时间分割log日志并写入本地磁盘，需要在app.js文件中引入fs和file-stream-rotator模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;); </span><br><span class="line">let FileStreamRotator = require(&apos;file-stream-rotator&apos;);  // 日志按时间分割模块</span><br><span class="line"></span><br><span class="line">// 下面代码写在var app = express();下面</span><br><span class="line">let logDir = path.join(__dirname, &apos;log&apos;);</span><br><span class="line"></span><br><span class="line">// 检查是否存在logDir这个目录没有则创建</span><br><span class="line">fs.existsSync(logDir) || fs.mkdirSync(logDir);</span><br><span class="line"></span><br><span class="line">// 日志分割流</span><br><span class="line">let accessLogStream = FileStreamRotator.getStream(&#123;</span><br><span class="line">    date_format: &apos;YYYYMMDD&apos;,</span><br><span class="line">    filename: path.join(logDir, &apos;access-%DATE%.log&apos;),</span><br><span class="line">    frequency: &apos;daily&apos;,</span><br><span class="line">    verbose: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 日志中间件</span><br><span class="line">app.use(logger(&apos;combined&apos;, &#123; stream: accessLogStream &#125;));</span><br></pre></td></tr></table></figure></p><h2 id="创建公共文件"><a href="#创建公共文件" class="headerlink" title="创建公共文件"></a>创建公共文件</h2><p>项目根目录创建common文件夹，再里面再新建一个common.json文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;API&quot;: &quot;http://api.zhuishushenqi.com&quot;,</span><br><span class="line">    &quot;PIC&quot;: &quot;http://statics.zhuishushenqi.com&quot;,</span><br><span class="line">    &quot;CHAPTER&quot;: &quot;http://chapter2.zhuishushenqi.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>API域名: <a href="http://api.zhuishushenqi.com" target="_blank" rel="noopener">http://api.zhuishushenqi.com</a><br>图片域名: <a href="http://statics.zhuishushenqi.com" target="_blank" rel="noopener">http://statics.zhuishushenqi.com</a><br>章节域名: <a href="http://chapter2.zhuishushenqi.com" target="_blank" rel="noopener">http://chapter2.zhuishushenqi.com</a></p><h2 id="首页接口"><a href="#首页接口" class="headerlink" title="首页接口"></a>首页接口</h2><p>1.0版本首页接口直接返回最热榜前20条数据。<br>修改app.js 文件路由中间件配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(&apos;/index&apos;, indexRouter);</span><br></pre></td></tr></table></figure></p><p>修改routes/index.js 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let request = require(&apos;request&apos;);</span><br><span class="line">let common = require(&apos;../common/common.json&apos;); // 引用公共文件</span><br><span class="line">let router = express.Router();</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">  首页数据追书最热榜 Top100</span><br><span class="line">  获取单一排行榜</span><br><span class="line">  http://api.zhuishushenqi.com/ranking/&#123;rankingId&#125;</span><br><span class="line">*/</span><br><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">  // 请求追书最热榜 Top100</span><br><span class="line">  request.get(`$&#123;common.API&#125;/ranking/54d42d92321052167dfb75e3`, function (error, response, body) &#123;</span><br><span class="line">    if (error)&#123;</span><br><span class="line">      res.send(JSON.stringify(&#123;&quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 解析返回数据取前20条，并添加图片url链接</span><br><span class="line">    body = JSON.parse(body);</span><br><span class="line"></span><br><span class="line">    if (body.ok)&#123;</span><br><span class="line">      let books = body.ranking.books.slice(0, 19);</span><br><span class="line">      books.forEach(element =&gt; &#123;</span><br><span class="line">        element.cover = common.PIC + element.cover;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;books&quot;: books, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;rankingId有问题&quot; &#125;));</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></p><p>访问<a href="http://localhost:3000/index" target="_blank" rel="noopener">http://localhost:3000/index</a> 就可以看到返回的数据了。</p><h2 id="搜索接口"><a href="#搜索接口" class="headerlink" title="搜索接口"></a>搜索接口</h2><p>1.0版本的搜索接口只取前40条数据，可以模糊查询。<br>修改app.js 文件路由中间件配置，把users删掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let searchRouter = require(&apos;./routes/search&apos;);</span><br><span class="line">app.use(&apos;/search&apos;, searchRouter);</span><br></pre></td></tr></table></figure></p><p>然后把routes文件夹下面的users.js删除，新建search.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">let express = require(&apos;express&apos;);</span><br><span class="line">let request = require(&apos;request&apos;);</span><br><span class="line">let common = require(&apos;../common/common.json&apos;); // 引用公共文件</span><br><span class="line">let router = express.Router();</span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line">  模糊搜索接口</span><br><span class="line">  返回模糊搜索前40条数据</span><br><span class="line">  http://api.zhuishushenqi.com/book/fuzzy-search?query=&#123;name&#125;</span><br><span class="line">*/</span><br><span class="line">router.get(&apos;/&apos;, function(req, res, next) &#123;</span><br><span class="line">  // 判断query参数有没有传递过来</span><br><span class="line">  if (req.query.query)&#123;</span><br><span class="line">    // req.query.query 编码转义</span><br><span class="line">    let query = encodeURIComponent(req.query.query);</span><br><span class="line">    request.get(`$&#123;common.API&#125;/book/fuzzy-search?query=$&#123;query&#125;`, function (error, response, body) &#123;</span><br><span class="line">      if (error)&#123;</span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">       // 解析返回数据</span><br><span class="line">      body = JSON.parse(body);</span><br><span class="line"></span><br><span class="line">      if (body.ok)&#123;</span><br><span class="line">        if (body.books.length == 0)&#123;</span><br><span class="line">          res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;没有找到书籍，换个名字试试吧。&quot; &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 取前40条，并添加图片url链接</span><br><span class="line">        let books = body.books.slice(0, 39);</span><br><span class="line">        books.forEach(element =&gt; &#123;</span><br><span class="line">          element.cover = common.PIC + element.cover;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 1, &quot;books&quot;: books, &quot;msg&quot;: &quot;OK&quot; &#125;));</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        res.send(JSON.stringify(&#123; &quot;flag&quot;: 0, &quot;msg&quot;: &quot;请求出错了...&quot; &#125;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    res.send(JSON.stringify(&#123;&quot;flag&quot;: 0, &quot;msg&quot;: &quot;请传入query参数&quot;&#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></p><p>访问<a href="http://localhost:3000/search/?query=遮天" target="_blank" rel="noopener">http://localhost:3000/search/?query=遮天</a> 就可以看到返回的数据了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/expressjs/morgan" target="_blank" rel="noopener">https://github.com/expressjs/morgan</a><br><a href="https://juejin.im/entry/593a3fdf61ff4b006c737ca4" target="_blank" rel="noopener">https://juejin.im/entry/593a3fdf61ff4b006c737ca4</a><br><a href="https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3" target="_blank" rel="noopener">https://github.com/jianhui1012/bookreader/wiki/API-%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用Express开发小说API接口服务1-0（一）&quot;&gt;&lt;a href=&quot;#使用Express开发小说API接口服务1-0（一）&quot; class=&quot;headerlink&quot; title=&quot;使用Express开发小说API接口服务1.0（一）&quot;&gt;&lt;/a&gt;使用Express开发小说API接口服务1.0（一）&lt;/h1&gt;&lt;p&gt;1.0版本技术栈使用express-generator、express、request、morgan、file-stream-rotator。接口用追书神器API。&lt;br&gt;目前接口设计有首页，小说详情页，搜索，小说文章列表页，排行API。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="API" scheme="http://blog.langpz.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>使用travis-ci自动构建Hexo</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo.html"/>
    <id>http://blog.langpz.com/使用travis-ci自动构建Hexo.html</id>
    <published>2018-05-15T16:30:49.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用travis-ci自动构建Hexo"><a href="#使用travis-ci自动构建Hexo" class="headerlink" title="使用travis-ci自动构建Hexo"></a>使用travis-ci自动构建Hexo</h1><p>持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。<br><a id="more"></a><br>Travis CI是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。这个软件的代码同时也是开源的，可以在GitHub上下载到，尽管开发者当前并不推荐在闭源项目中单独使用它。</p><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><p>本地写完文章  =&gt;  push github  =&gt;  GitHub触发Travis CI构建  =&gt;  执行命令  =&gt;  部署  =&gt;   完成。</p><h2 id="用github登陆travis-ci"><a href="#用github登陆travis-ci" class="headerlink" title="用github登陆travis-ci"></a>用github登陆travis-ci</h2><p><a href="https://travis-ci.com" target="_blank" rel="noopener">https://travis-ci.com</a>然后添加到你要激活的存储库。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180515180738.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后选择你要使用的仓库，我这里选择的是lanpangzhi.github.io，我放hexo博客的仓库。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180515180908.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>然后生成github和coding的Token。<br>先生成github的Token。<br><a href="https://github.com/settings/tokens" target="_blank" rel="noopener">https://github.com/settings/tokens</a><br>点击Generate new token。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180517132208.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>然后生成Token。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180517132418.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>开始生成coding的Token。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180517132723.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>点击新建令牌。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180517132941.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>复制令牌。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180517133513.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>登陆travis-ci把github和coding的Token复制到环境变量。<br><a href="https://travis-ci.com/" target="_blank" rel="noopener">https://travis-ci.com/</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180517133828.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>点击Settings。<br>添加CI_TOKEN和CO_TOKEN环境变量。<br>CI_TOKEN是github的Token。<br>CO_TOKEN是coding的Token。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180517134401.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>在项目根目录新建.travis.yml 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">- 8.9.0</span><br><span class="line">cache:</span><br><span class="line">  directories:</span><br><span class="line">  - node_modules</span><br><span class="line">before_install:</span><br><span class="line">- npm install hexo-cli -g</span><br><span class="line">install:</span><br><span class="line">- npm install</span><br><span class="line">script:</span><br><span class="line">- hexo clean</span><br><span class="line">- hexo generate</span><br><span class="line">after_script:</span><br><span class="line">  - cd ./public</span><br><span class="line">  - git init</span><br><span class="line">  - git config user.name &quot;github用户名&quot;</span><br><span class="line">  - git config user.email &quot;github邮箱&quot;</span><br><span class="line">  - git add .</span><br><span class="line">  - git commit -m &quot;TravisCI 自动部署&quot;</span><br><span class="line">  # Github Pages</span><br><span class="line">  - git push --force --quiet &quot;https://$&#123;CI_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master </span><br><span class="line">  # Coding Pages</span><br><span class="line">  - git push --force --quiet &quot;https://coding用户名:$&#123;CO_TOKEN&#125;@$&#123;CO_REF&#125;&quot; master:master</span><br><span class="line"></span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">  - indigo   这里替换你要监听的分支</span><br><span class="line"></span><br><span class="line">env:</span><br><span class="line"> global:</span><br><span class="line">   # Github Pages</span><br><span class="line">   - GH_REF: github.com/lanpangzhi/lanpangzhi.github.io  这里替换你的github仓库地址</span><br><span class="line">   # Coding Pages</span><br><span class="line">   - CO_REF: git.coding.net/bule/bule.coding.me.git  这里替换你的coding仓库地址</span><br></pre></td></tr></table></figure></p><p>然后提交github，travis-ci就会自动构建了。<br>现在写博客只需要两步操作，第一步 hexo new “新的文章”，第二步提交到github。travis-ci会帮你自动部署的。<br>省去了 hexo clean hexo g -d 的环节。</p><p>看到这张图就代表成功了。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/%E4%BD%BF%E7%94%A8travis-ci%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAHexo/QQ%E5%9B%BE%E7%89%8720180517131546.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><h2 id="如果使用git子模块的话请使用https地址，或者在-travis-yml文件禁用子模块，否则构建会报错，提示没有权限。"><a href="#如果使用git子模块的话请使用https地址，或者在-travis-yml文件禁用子模块，否则构建会报错，提示没有权限。" class="headerlink" title="如果使用git子模块的话请使用https地址，或者在.travis.yml文件禁用子模块，否则构建会报错，提示没有权限。"></a>如果使用git子模块的话请使用https地址，或者在.travis.yml文件禁用子模块，否则构建会报错，提示没有权限。</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.travis-ci.com/user/for-beginners" target="_blank" rel="noopener">https://docs.travis-ci.com/user/for-beginners</a><br><a href="https://zh.wikipedia.org/wiki/Travis_CI" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Travis_CI</a><br><a href="https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6250744</a><br><a href="https://blog.csdn.net/qinyuanpei/article/details/79388983" target="_blank" rel="noopener">https://blog.csdn.net/qinyuanpei/article/details/79388983</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用travis-ci自动构建Hexo&quot;&gt;&lt;a href=&quot;#使用travis-ci自动构建Hexo&quot; class=&quot;headerlink&quot; title=&quot;使用travis-ci自动构建Hexo&quot;&gt;&lt;/a&gt;使用travis-ci自动构建Hexo&lt;/h1&gt;&lt;p&gt;持续集成(CI)是一种软件开发实践，即团队开发成员经常集成他们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。&lt;br&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://blog.langpz.com/tags/Hexo/"/>
    
      <category term="travis-ci" scheme="http://blog.langpz.com/tags/travis-ci/"/>
    
      <category term="自动构建" scheme="http://blog.langpz.com/tags/%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/"/>
    
      <category term="持续集成" scheme="http://blog.langpz.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>使用express-generator快速生成express应用</title>
    <link href="http://blog.langpz.com/%E4%BD%BF%E7%94%A8express-generator%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90express%E5%BA%94%E7%94%A8.html"/>
    <id>http://blog.langpz.com/使用express-generator快速生成express应用.html</id>
    <published>2018-05-14T16:08:03.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用express-generator快速生成express应用"><a href="#使用express-generator快速生成express应用" class="headerlink" title="使用express-generator快速生成express应用"></a>使用express-generator快速生成express应用</h1><p>express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g express-generator</span><br></pre></td></tr></table></figure><p>需要全局安装。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在要创建应用的文件夹下面执。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express -e myapp</span><br></pre></td></tr></table></figure></p><p>-e： 使用ejs模板<br>myapp： 应用名字</p><p>然后安装依赖项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myapp</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>执行应用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set DEBUG=myapp:* &amp; npm start</span><br></pre></td></tr></table></figure></p><p>生成完应用的时候会有提示因为我是Windows系统所以提示set。<br>MacOS 或 Linux 上不用使用set<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEBUG=myapp:* npm start</span><br></pre></td></tr></table></figure></p><p>然后在浏览器中输入 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 以访问此应用程序。<br>可以根据自己的需要修改文件，来满足自己项目的需要。</p><h2 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    --version        输出版本号</span><br><span class="line">-e, --ejs            添加ejs引擎支持</span><br><span class="line">    --pug            添加pug引擎支持</span><br><span class="line">    --hbs            添加handlebars引擎支持</span><br><span class="line">-H, --hogan          添加hogan.js引擎支持</span><br><span class="line">-v, --view &lt;engine&gt;  添加以下模板引擎支持(dust|ejs|hbs|hjs|jade|pug|twig|vash) 默认jade  </span><br><span class="line">    --no-view        使用静态HTML代替视图模板引擎</span><br><span class="line">-c, --css &lt;engine&gt;   添加样式扩展语言 (less|stylus|compass|sass) 默认css  </span><br><span class="line">    --git            添加 .gitignore 忽略文件</span><br><span class="line">-h, --help           输出帮助信息</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/expressjs/generator" target="_blank" rel="noopener">https://github.com/expressjs/generator</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用express-generator快速生成express应用&quot;&gt;&lt;a href=&quot;#使用express-generator快速生成express应用&quot; class=&quot;headerlink&quot; title=&quot;使用express-generator快速生成express应用&quot;&gt;&lt;/a&gt;使用express-generator快速生成express应用&lt;/h1&gt;&lt;p&gt;express-generator是Express应用的快速生成器，可以随意使用此结构或者对其进行修改以最大程度满足自己的需求。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="express-generator" scheme="http://blog.langpz.com/tags/express-generator/"/>
    
  </entry>
  
  <entry>
    <title>node爬虫</title>
    <link href="http://blog.langpz.com/node%E7%88%AC%E8%99%AB.html"/>
    <id>http://blog.langpz.com/node爬虫.html</id>
    <published>2018-05-12T15:37:42.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node爬虫"><a href="#node爬虫" class="headerlink" title="node爬虫"></a>node爬虫</h1><p>什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。<br><a id="more"></a></p><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>爬取<a href="http://top.zhaopin.com" target="_blank" rel="noopener">http://top.zhaopin.com</a>  智联网站上的全国的竞争最激烈三个月内前十的岗位。不需要定时爬取。使用request和cheerio模块。node版本7.6.0、npm版本4.1.2</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install request cheerio -S</span><br></pre></td></tr></table></figure><p>request 模块是一个简化的HTTP客户端。<br>cheerio 模块专为服务器设计的核心jQuery的快速，灵活和精益的实现。可以把爬到的内容和jQuery一样使用。</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const request = require(&apos;request&apos;);</span><br><span class="line">const cheerio = require(&apos;cheerio&apos;);</span><br><span class="line"></span><br><span class="line">// 发起请求</span><br><span class="line">request(&apos;http://top.zhaopin.com&apos;, (error, response, body) =&gt; &#123;</span><br><span class="line">    if(error)&#123;</span><br><span class="line">        console.error(error);</span><br><span class="line">    &#125;</span><br><span class="line">    let json = &#123;&#125;;</span><br><span class="line">    // 获取到的内容放到cheerio模块</span><br><span class="line">    const $ = cheerio.load(body);</span><br><span class="line"></span><br><span class="line">    // jQuery 遍历  #hotJobTop .topList li  是通过http://top.zhaopin.com 分析页面结构得到的</span><br><span class="line">    $(&apos;#hotJobTop .topList li&apos;).each(function (index) &#123;</span><br><span class="line">        let obj = json[index] = &#123;&#125;;</span><br><span class="line">        obj.name = $(this).find(&apos;.title&apos;).text().trim();</span><br><span class="line">        obj.num = $(this).find(&apos;.paddingR10&apos;).text().trim();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 打印数据</span><br><span class="line">    console.log(json);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行 node app.js 就会得到如下结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; name: &apos;Java开发工程师&apos;, num: &apos;340538人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;软件工程师&apos;, num: &apos;220873人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;销售代表&apos;, num: &apos;175053人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;会计/会计师&apos;, num: &apos;168225人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;行政专员/助理&apos;, num: &apos;150913人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;WEB前端开发&apos;, num: &apos;140979人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;助理/秘书/文员&apos;, num: &apos;139098人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;软件测试&apos;, num: &apos;136399人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;人力资源专员/助理&apos;, num: &apos;123482人/天&apos; &#125;,</span><br><span class="line">  &#123; name: &apos;用户界面（UI）设计&apos;, num: &apos;107505人/天&apos; &#125; ]</span><br></pre></td></tr></table></figure></p><p>一个简单的爬虫就写好了，看看前十有没有你从事的岗位吧！</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/request/request" target="_blank" rel="noopener">https://github.com/request/request</a><br><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">https://github.com/cheeriojs/cheerio</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;node爬虫&quot;&gt;&lt;a href=&quot;#node爬虫&quot; class=&quot;headerlink&quot; title=&quot;node爬虫&quot;&gt;&lt;/a&gt;node爬虫&lt;/h1&gt;&lt;p&gt;什么是爬虫呢，是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。为什么选用node呢，因为我是前端，当然要用js实现。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="爬虫" scheme="http://blog.langpz.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>node连接MySQL</title>
    <link href="http://blog.langpz.com/node%E8%BF%9E%E6%8E%A5MySQL.html"/>
    <id>http://blog.langpz.com/node连接MySQL.html</id>
    <published>2018-05-10T15:40:04.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node连接MySQL"><a href="#node连接MySQL" class="headerlink" title="node连接MySQL"></a>node连接MySQL</h1><p>之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。<br><a id="more"></a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const mysql = require(&apos;mysql&apos;);</span><br><span class="line"></span><br><span class="line">let connection = mysql.createConnection(&#123;</span><br><span class="line">    host : &apos;localhost&apos;,</span><br><span class="line">    user : &apos;root&apos;,</span><br><span class="line">    password : &apos;password&apos;,</span><br><span class="line">    database : &apos;test&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">connection.connect(function(err) &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.error(&apos;连接出错: &apos; + err.stack);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  console.log(&apos;连接成功 id &apos; + connection.threadId);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>host：连接的服务器<br>user：用户名默认是root<br>password：之前设置的MySQL密码<br>database： 要连接的库</p><h2 id="常用的SQL语句"><a href="#常用的SQL语句" class="headerlink" title="常用的SQL语句"></a>常用的SQL语句</h2><p>SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。</p><p>增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO user (username, pass) VALUES (&apos;blog.langpz.com&apos;, &apos;123456&apos;);</span><br></pre></td></tr></table></figure></p><p>INSERT INTO 表名称 VALUES (值1, 值2,….)<br>指定所要插入数据的列<br>INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….)</p><p>删<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM user  WHERE id = 0</span><br></pre></td></tr></table></figure></p><p>DELETE FROM 表名称 WHERE 列名称 = 值<br>不加WHERE会删除所有行<br>WHERE子句用于规定选择的标准。</p><p>改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE user SET pass = &apos;bbb&apos; WHERE username = &apos;张三&apos;</span><br></pre></td></tr></table></figure></p><p>UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</p><p>查<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user</span><br></pre></td></tr></table></figure></p><p>SELECT 列名 FROM 表名 注： * 代表全部</p><h2 id="node操作MySQL"><a href="#node操作MySQL" class="headerlink" title="node操作MySQL"></a>node操作MySQL</h2><p>查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;SELECT * FROM user WHERE username = &quot;blog.langpz.com&quot;&apos;, (err, results, fields) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;DELETE FROM user  WHERE id = 1&apos;, (err, results) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;INSERT INTO user(username, pass) VALUES(?, ?)&apos;,[&apos;lan&apos;, &apos;abc&apos;], (err, results) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">connection.query(&apos;UPDATE user SET pass = &quot;bbb&quot; WHERE username = &quot;lan&quot;&apos;, (err, results) =&gt; &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>终止连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connection.end(function(err) &#123;</span><br><span class="line">  // The connection is terminated now</span><br><span class="line">&#125;);</span><br><span class="line">connection.destroy();</span><br></pre></td></tr></table></figure></p><p>调用这两个方法都可以。<br>基本操作就是这个流程，可以通过路由封装接口，写一个CRUD应用，mysql模块更多参数可以去看github。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/mysqljs/mysql" target="_blank" rel="noopener">https://github.com/mysqljs/mysql</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;node连接MySQL&quot;&gt;&lt;a href=&quot;#node连接MySQL&quot; class=&quot;headerlink&quot; title=&quot;node连接MySQL&quot;&gt;&lt;/a&gt;node连接MySQL&lt;/h1&gt;&lt;p&gt;之前讲了怎么安装MySQL，今天就讲下这么用node去连接操作MySQL。&lt;br&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="http://blog.langpz.com/tags/Node-js/"/>
    
      <category term="MySQL" scheme="http://blog.langpz.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装MongoDB</title>
    <link href="http://blog.langpz.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB.html"/>
    <id>http://blog.langpz.com/Windows下安装MongoDB.html</id>
    <published>2018-05-08T15:30:32.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下安装MongoDB"><a href="#Windows下安装MongoDB" class="headerlink" title="Windows下安装MongoDB"></a>Windows下安装MongoDB</h1><p>MongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。<br><a id="more"></a></p><h2 id="MongoDB特点"><a href="#MongoDB特点" class="headerlink" title="MongoDB特点"></a>MongoDB特点</h2><p>和关系型数据库比较，面向文档的数据库不再有“行”（row）的概念，取而代之的是更为灵活的“文档”（document）模型。通过再文档中嵌入文档和数组，面向文档的方法能够仅使用一条记录来表现复杂的层次关系。<br>另外，不再有预定义模式，文档的键（key）和值（value）不再是固定的类型和大小。由于没有固定的模式，根据需要添加或删除字段变得更容易。可以进行快速迭代，所以开发进程得到加快。</p><h2 id="MongoDB基本概念"><a href="#MongoDB基本概念" class="headerlink" title="MongoDB基本概念"></a>MongoDB基本概念</h2><p>文档是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行。<br>集合(collection)可以看作是一个拥有动态模式(dynamic schema)的表。<br>MongoDB的一个实例可以拥有多个相互独立的数据库(database)，每一个数据库都拥有自己的集合。<br>每一个文档都有一个特殊的键“_id”，这个键在文档所属的集合中是唯一的。</p><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p><a href="https://www.mongodb.com/download-center#atlas" target="_blank" rel="noopener">下载地址</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MongoDB/QQ%E5%9B%BE%E7%89%8720180508155317.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>点击下载，下载完安装，用默认设置。</p><h2 id="运行MongoDB"><a href="#运行MongoDB" class="headerlink" title="运行MongoDB"></a>运行MongoDB</h2><p>命令提示符（cmd）执行，具体路径需要看安装的版本，我的是3.6版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Program Files\MongoDB\Server\3.6\bin</span><br><span class="line">mongod --dbpath d:\db</span><br></pre></td></tr></table></figure></p><p>控制台会输出一些东西，没有报错MongoDB就启动了。<br>这样启动比较麻烦，每次都要启动，所以可以把它注册成windows 的服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 使用管理员权限运行</span><br><span class="line">mongod --install --dbpath d:\data\db --logpath d:\data\log\log.txt</span><br><span class="line">net start MongoDB  // 启动服务</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">services.msc // 查看服务</span><br><span class="line">net stop mongodb   // 停止服务</span><br></pre></td></tr></table></figure><p>删除服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongod --remove --serviceName MongoDB  // MongoDB是服务名</span><br></pre></td></tr></table></figure></p><p>MongoDB 还可以通过配置文件启动<br>可以去官网查看<a href="https://docs.mongodb.com/manual/reference/configuration-options/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/configuration-options/</a></p><h2 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h2><p>在打开一个命令提示符（cmd）之前运行的MongoDB那个不要关闭，因为没有注册成windows的服务，关闭就找不到数据库了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Program Files\MongoDB\Server\3.6\bin</span><br><span class="line">mongo</span><br></pre></td></tr></table></figure></p><p>这样就链接上数据库了，当然还会输出一大堆东西。</p><h2 id="操作MongoDB"><a href="#操作MongoDB" class="headerlink" title="操作MongoDB"></a>操作MongoDB</h2><p>我们先创建一个数据库，再刚才连接MongoDB的cmd执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use test02</span><br></pre></td></tr></table></figure></p><p>创建一个test02的数据库并切换过去。<br>db变量指向当前数据库。<br>向集合里插入文档，之前也讲了MongoDB没有预定义模式，所以不用新建表和表结构了。<br>insert方法 把一条文档保存到集合里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.insert(&#123;&quot;name&quot;, &quot;lanpangzhi&quot;, &quot;age&quot;: 18&#125;)</span><br></pre></td></tr></table></figure></p><p>查看集合里面的文档。<br>find和findOne方法可以用于查询集合里的文档。只想查看一个文件，可以用findOne<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.find()</span><br><span class="line">db.user_table.findOne()</span><br></pre></td></tr></table></figure></p><p>find和findOne还可以接受一个查询文档作为限定条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.find(&#123;&quot;name&quot;: &quot;lanpangzhi&quot;&#125;)</span><br></pre></td></tr></table></figure></p><p>更新集合里面的文档<br>update方法接受（至少）两个参数：第一个是限定条件（用于匹配待更新的文档），第二个是新的文档。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.update(&#123;name: lanpangzhi&#125;,&#123;&quot;name&quot;: &quot;lanpangzhi&quot;, &quot;age&quot;: 18, &quot;sex&quot;: 1&#125;);</span><br></pre></td></tr></table></figure></p><p>删除集合里面的文档<br>remove方法可将数据库的集合永久删除，如果不加参数默认把集合里面所有的文档删除。它可以接受一个限定条件的文档作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user_table.remove(&#123;&quot;name&quot;: &quot;aaa&quot;&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Windows下安装MongoDB&quot;&gt;&lt;a href=&quot;#Windows下安装MongoDB&quot; class=&quot;headerlink&quot; title=&quot;Windows下安装MongoDB&quot;&gt;&lt;/a&gt;Windows下安装MongoDB&lt;/h1&gt;&lt;p&gt;MongoDB是一种面向文档的数据库管理系统，由C++撰写而成，以此来解决应用程序开发社区中的大量现实问题。&lt;br&gt;
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://blog.langpz.com/tags/MongoDB/"/>
    
      <category term="Windows" scheme="http://blog.langpz.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>Windows下安装MySQL</title>
    <link href="http://blog.langpz.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL.html"/>
    <id>http://blog.langpz.com/Windows下安装MySQL.html</id>
    <published>2018-05-08T11:02:20.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下安装MySQL"><a href="#Windows下安装MySQL" class="headerlink" title="Windows下安装MySQL"></a>Windows下安装MySQL</h1><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。<br><a id="more"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">下载地址</a><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508112259.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>点击，进入页面。注：MySQL安装程序是32位的，但会安装32位和64位二进制文件。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508113607.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>点击download然后跳转到页面。可以不需要登陆和注册也可以下载。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508113906.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>再点击，安装程序就下载了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>打开安装程序，勾选同意协议，点击下一步(Next)<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Windows%E4%B8%8B%E5%AE%89%E8%A3%85MySQL/QQ%E5%9B%BE%E7%89%8720180508115626.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><br>现在只安装MySQL的服务端，点击下一步然后安装。<br>设置MySQL密码，继续下一步。然后完成，其余配置都是用默认配置。</p><h2 id="使用Navicat-for-MySQL-管理MySQL"><a href="#使用Navicat-for-MySQL-管理MySQL" class="headerlink" title="使用Navicat for MySQL 管理MySQL"></a>使用Navicat for MySQL 管理MySQL</h2><p><a href="https://www.navicat.com.cn/download/navicat-for-mysql" target="_blank" rel="noopener">下载地址</a><br>可以用它去管理MySQL。新建库，新建表，修改数据删除数据。</p><h2 id="MySQL基本概念"><a href="#MySQL基本概念" class="headerlink" title="MySQL基本概念"></a>MySQL基本概念</h2><p>库： 文件夹-用来管理，无法存放数据，一个库可以存放很多张表。<br>表： 文件-存放数据用的。<br>列: 一列(数据元素) 包含了相同的数据, 例如用户的数据。<br>行：一行是一组相关的数据，例如一条用户名和密码的数据。<br>主键：主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。<br>外键：外键用于关联两个表。</p><h2 id="MySQL常用数据类型"><a href="#MySQL常用数据类型" class="headerlink" title="MySQL常用数据类型"></a>MySQL常用数据类型</h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">INT</td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center">FLOAT</td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center">DATE</td><td style="text-align:center">日期值</td></tr><tr><td style="text-align:center">DATETIME</td><td style="text-align:center">混合日期和时间值</td></tr><tr><td style="text-align:center">TIME</td><td style="text-align:center">时间值或持续时间</td></tr><tr><td style="text-align:center">VARCHAR</td><td style="text-align:center">变长字符串</td></tr><tr><td style="text-align:center">CHAR</td><td style="text-align:center">定长字符串</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/jaywcjlove/handbook/blob/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md" target="_blank" rel="noopener">https://github.com/jaywcjlove/handbook/blob/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Windows下安装MySQL&quot;&gt;&lt;a href=&quot;#Windows下安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;Windows下安装MySQL&quot;&gt;&lt;/a&gt;Windows下安装MySQL&lt;/h1&gt;&lt;p&gt;MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。&lt;br&gt;
    
    </summary>
    
    
      <category term="Windows" scheme="http://blog.langpz.com/tags/Windows/"/>
    
      <category term="MySQL" scheme="http://blog.langpz.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Express路由</title>
    <link href="http://blog.langpz.com/Express%E8%B7%AF%E7%94%B1.html"/>
    <id>http://blog.langpz.com/Express路由.html</id>
    <published>2018-05-07T17:50:08.000Z</published>
    <updated>2018-06-21T08:05:23.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express路由"><a href="#Express路由" class="headerlink" title="Express路由"></a>Express路由</h1><p>之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。<br><a id="more"></a></p><p>一个网站下面可能有很多地址例如:<br>www.langpz.com/aaa<br>user/<br>www.langpz.com/user/aaa<br>www.langpz.com/user/bbb<br>www.langpz.com/user/ccc<br>vip/<br>www.langpz.com/vip/aaa<br>www.langpz.com/vip/bbb<br>www.langpz.com/vip/ccc<br>等等。。。<br>咱们可以拆分成vip和user两个目录目录下再放子路由。<br>先安装express 然后在项目根目录建一个app.js和routers文件夹，routers文件夹里面再建一个index.js文件和vip、user两个目录，两个目录下面分别建立index.js文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const routers = require(&apos;./routers&apos;);  //引入路由</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/vip&apos;, routers.vip);   // 设置/vip路由中间件</span><br><span class="line">app.use(&apos;/user&apos;, routers.user);  // 设置/user路由中间件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// routers/index.js</span><br><span class="line">let vip = require(&apos;./vip&apos;); // 引入vip文件下面的路由</span><br><span class="line">let user = require(&apos;./user&apos;);   // 引入user文件下面的路由</span><br><span class="line">// 导出路由</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    vip,</span><br><span class="line">    user</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// routers/vip/index.js</span><br><span class="line">const express = require(&apos;express&apos;); // 必须要引入express</span><br><span class="line"></span><br><span class="line">let routerVip = express.Router();   // 创建router实例</span><br><span class="line"></span><br><span class="line">// 添加路由配置</span><br><span class="line">routerVip.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是vip根目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerVip.get(&apos;/aaa&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是vip/aaa目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerVip.get(&apos;/bbb&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是vip/bbb目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line">// 导出路由</span><br><span class="line">module.exports = routerVip;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// routers/user/index.js</span><br><span class="line">const express = require(&apos;express&apos;); // 必须要引入express</span><br><span class="line"></span><br><span class="line">let routerUser = express.Router();  // 创建router实例</span><br><span class="line"></span><br><span class="line">// 添加路由配置</span><br><span class="line">routerUser.get(&apos;/&apos;, (req, res) =&gt;&#123;</span><br><span class="line">    res.send(&apos;我是user根目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerUser.get(&apos;/aaa&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是user/aaa目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">routerUser.get(&apos;/bbb&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    res.send(&apos;我是user/bbb目录&apos;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 导出路由</span><br><span class="line">module.exports = routerUser;</span><br></pre></td></tr></table></figure><p>然后执行 node app.js 再浏览器输入<a href="http://localhost:8000/user/aaa、http://localhost:8000/vip/aaa，就可以来回切换路由了，如果新增了一个路由模块就在routers文件夹下，再新建文件夹划分路由，这样路由文件比较清晰，后期维护起来也方便。" target="_blank" rel="noopener">http://localhost:8000/user/aaa、http://localhost:8000/vip/aaa，就可以来回切换路由了，如果新增了一个路由模块就在routers文件夹下，再新建文件夹划分路由，这样路由文件比较清晰，后期维护起来也方便。</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Express路由&quot;&gt;&lt;a href=&quot;#Express路由&quot; class=&quot;headerlink&quot; title=&quot;Express路由&quot;&gt;&lt;/a&gt;Express路由&lt;/h1&gt;&lt;p&gt;之前在Express入坑里面简单讲了下路由的用法，现在就讲下如果再项目中怎么配置路由。&lt;br&gt;
    
    </summary>
    
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="路由" scheme="http://blog.langpz.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>Express框架cookie和session</title>
    <link href="http://blog.langpz.com/Express%E6%A1%86%E6%9E%B6cookie%E5%92%8Csession.html"/>
    <id>http://blog.langpz.com/Express框架cookie和session.html</id>
    <published>2018-05-06T17:32:54.000Z</published>
    <updated>2018-06-21T08:05:23.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Express框架cookie和session"><a href="#Express框架cookie和session" class="headerlink" title="Express框架cookie和session"></a>Express框架cookie和session</h1><p>HTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。<br><a id="more"></a></p><h2 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h2><p>cookie存在浏览器端，每次请求都会带上。<br>    缺点：不安全(用户可以随便串改)，大小（4k）。</p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session只存在服务器端。<br>    优点：容量不限，比较安全（用户接触不到）。<br>    session实现是基于cookie的。<br>风险：session_id 被泄露漏 session劫持。<br>    提醒用户不在在控制台输入(console)输入代码。<br>    session_id 足够复杂，定期更换。</p><h2 id="Express操作cookie"><a href="#Express操作cookie" class="headerlink" title="Express操作cookie"></a>Express操作cookie</h2><p>先安装cookie-parser。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cookie-parser -S</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const cookieParser = require(&apos;cookie-parser&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser()); // 设置cookieParser 中间件</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.cookies); // 获取cookie</span><br><span class="line">    res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;); // 设置cookie</span><br><span class="line">    res.send(&apos;OK&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><p>在cmd执行 node app.js 浏览器输入<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 第一次控制台输出{}，再刷新就输出{user: ‘lanpangzhi’ }。<br>现在就能获取和设置cookie了，但是有个问题，浏览器执行document.cookie = “user=aaa”,浏览器再刷新控制台就会输出{user: ‘aaa’ }。<br>这样使用cookie不安全，敏感信息容易被篡改，所以要使用带签名的cookie。</p><p>带签名的cookie<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const cookieParser = require(&apos;cookie-parser&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieParser(&apos;abc123456abc&apos;)); // 设置cookieParser 中间件  使用签名必须要设置字符串。</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    console.log(req.cookies); // 获取cookie</span><br><span class="line">    console.log(req.signedCookies); // 获取带签名的cookie</span><br><span class="line">    res.cookie(&apos;user&apos;, &apos;lanpangzhi&apos;, &#123;</span><br><span class="line">        signed: true // 设置带签名的cookie</span><br><span class="line">    &#125;); </span><br><span class="line">    res.send(&apos;OK&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure></p><p>再执行，就会发现浏览器cookie的值变成了s%3Alanpangzhi.i6hEUuhD%2Fd0miBMsGyRdktiDFmi%2BYfiJhQTcqKpQqIc ，再修改cookie的值，控制台就会输出{ user: false }，这样cookie就不会被简单的篡改了。</p><p>req.cookies 获取cookie。<br>res.cookie(name, value [, options]);<br>    name: cookie的名称(string)。<br>    value: cookie的值，(string or object)。<br>    options：options参数是一个可以具有以下属性的对象。</p><h3 id="如下"><a href="#如下" class="headerlink" title="如下"></a>如下</h3><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">类型</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">domain</td><td style="text-align:center">String</td><td style="text-align:left">cookie的域名。 默认为网站的域名。</td></tr><tr><td style="text-align:center">encode</td><td style="text-align:center">Function</td><td style="text-align:left">用于cookie值编码的同步函数。 默认为encodeURIComponent。</td></tr><tr><td style="text-align:center">expires</td><td style="text-align:center">Date</td><td style="text-align:left">cookie的有效期（如果未指定或设置为0），则创建会话cookie。</td></tr><tr><td style="text-align:center">httpOnly</td><td style="text-align:center">Boolean</td><td style="text-align:left">将cookie标记为仅可由Web服务器访问。默认false</td></tr><tr><td style="text-align:center">maxAge</td><td style="text-align:center">Number</td><td style="text-align:left">设置cookie的到期时间、相对于当前时间的到期时间（以毫秒为单位）。</td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">String</td><td style="text-align:left">cookie的路径。 默认为“/”</td></tr><tr><td style="text-align:center">secure</td><td style="text-align:center">Boolean</td><td style="text-align:left">将cookie标记为仅与HTTPS一起使用。默认false</td></tr><tr><td style="text-align:center">signed</td><td style="text-align:center">Boolean</td><td style="text-align:left">对cookie进行签名。默认false</td></tr></tbody></table><h2 id="Express操作session"><a href="#Express操作session" class="headerlink" title="Express操作session"></a>Express操作session</h2><p>先安装cookie-session。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cookie-session -S</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">const express = require(&apos;express&apos;);</span><br><span class="line">const cookieSession = require(&apos;cookie-session&apos;);</span><br><span class="line"></span><br><span class="line">let app = express();</span><br><span class="line"></span><br><span class="line">app.use(cookieSession(&#123;</span><br><span class="line">    secret: &apos;aaaa&apos;</span><br><span class="line">&#125;));  // 设置cookieSession中间件</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">    if (req.session[&apos;num&apos;]) &#123;</span><br><span class="line">        req.session[&apos;num&apos;]++;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        req.session[&apos;num&apos;] = 1; // 设置session</span><br><span class="line">    &#125;</span><br><span class="line">    res.send(`访问$&#123;req.session[&quot;num&quot;]&#125;次`);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(8000);</span><br></pre></td></tr></table></figure><p>在cmd执行 node app.js 浏览器输入<a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a>  刷新浏览器就可以看到访问几次，把所有浏览器都关闭session就失效了，再进入页面就从第一次开始了。<br>更多方法还有详细参数可以去github自行参考。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://expressjs.com/en/4x/api.html" target="_blank" rel="noopener">http://expressjs.com/en/4x/api.html</a><br><a href="https://github.com/expressjs/cookie-parser" target="_blank" rel="noopener">https://github.com/expressjs/cookie-parser</a><br><a href="https://github.com/expressjs/cookie-session" target="_blank" rel="noopener">https://github.com/expressjs/cookie-session</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Express框架cookie和session&quot;&gt;&lt;a href=&quot;#Express框架cookie和session&quot; class=&quot;headerlink&quot; title=&quot;Express框架cookie和session&quot;&gt;&lt;/a&gt;Express框架cookie和session&lt;/h1&gt;&lt;p&gt;HTTP协议是无状态的，所以要通过一些机制来记录用户的信息。cookie是存在浏览器端的，session是存在服务器端。&lt;br&gt;
    
    </summary>
    
    
      <category term="Express" scheme="http://blog.langpz.com/tags/Express/"/>
    
      <category term="cookie" scheme="http://blog.langpz.com/tags/cookie/"/>
    
      <category term="session" scheme="http://blog.langpz.com/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>javascript数据类型转换</title>
    <link href="http://blog.langpz.com/javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html"/>
    <id>http://blog.langpz.com/javascript数据类型转换.html</id>
    <published>2018-05-05T17:14:25.000Z</published>
    <updated>2018-06-21T08:05:23.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="javascript数据类型转换"><a href="#javascript数据类型转换" class="headerlink" title="javascript数据类型转换"></a>javascript数据类型转换</h1><p>在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。<br><a id="more"></a></p><h2 id="默认是false的五个值"><a href="#默认是false的五个值" class="headerlink" title="默认是false的五个值"></a>默认是false的五个值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null undefined NaN 0 &apos;&apos;</span><br></pre></td></tr></table></figure><p>记住只有这五个值是假的剩下的全部是真的。</p><h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><ol><li>如果是一个值判断是否是真假，除了默认是false的五个值剩下的全部是true。</li><li>如果是两个值比较是否相等，遵循如下规则。<br> val1 == val2 如果两个值可能不是同一数据类型，如果是==比较的话，会默认进行数据转换。<br> 2.1 object == object，比较永远不相等。<br> 2.2 object == string 先将对象转换成字符串（调用toString方法），然后再比较。<pre><code>[] 转换成字符串 &quot;&quot;{} 转换成字符串 &quot;[object Object]&quot;</code></pre> 2.3 object == boolean 先将对象转换成字符串（toString），再把字符串转换成数字（Number）、布尔值转换成数字（true 转换成 1 false 换成成 0）然后让两个数字进行比较。<pre><code>Number(&quot;&quot;) 会输出 0</code></pre> 2.4 object == number  先将对象转换成字符串（toString），再把字符串转换成数字（Number），再进行比较。<br> 2.5 number == boolean 布尔值转换成数字，然后再比较。<br> 2.6 number == string  字符串转换成数字，然后再比较。<br> 2.7 string == boolean 都转换成数字，，然后再比较。<br> 2.8 null == undefined 结果是true。<br> 2.9 null 或者 undefined 比较另外的所有值，结果都是false，不相等。</li></ol><p>例如：<br>    [] == false 返回 true 2.3规则。<br>     [] == []  返回 false 2.1规则。<br>     2 == true 返回 false 2.5规则。<br>=== 三个等号还会比较数据类型。<br>这些规则背下来，就能完美的应付这样的面试题了，加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;javascript数据类型转换&quot;&gt;&lt;a href=&quot;#javascript数据类型转换&quot; class=&quot;headerlink&quot; title=&quot;javascript数据类型转换&quot;&gt;&lt;/a&gt;javascript数据类型转换&lt;/h1&gt;&lt;p&gt;在面试中经常会碰见问类型转换的问题，例如[] == false、[] == {}返回的是真还是假等等。。。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.langpz.com/tags/javascript/"/>
    
      <category term="数据类型转换" scheme="http://blog.langpz.com/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="面试题" scheme="http://blog.langpz.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Git生成SSH公钥</title>
    <link href="http://blog.langpz.com/Git%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5.html"/>
    <id>http://blog.langpz.com/Git生成SSH公钥.html</id>
    <published>2018-05-05T16:40:31.000Z</published>
    <updated>2018-06-21T08:05:23.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git生成SSH公钥"><a href="#Git生成SSH公钥" class="headerlink" title="Git生成SSH公钥"></a>Git生成SSH公钥</h1><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。<br><a id="more"></a></p><h2 id="查看公钥是否生成过"><a href="#查看公钥是否生成过" class="headerlink" title="查看公钥是否生成过"></a>查看公钥是否生成过</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls  # 在Git bash下执行</span><br></pre></td></tr></table></figure><p>或者 C:\Users\Administrator.ssh 访问这个目录。<br>看有没有用 something 和 something.pub 来命名的一对文件，这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。如果有公钥直接打开 id_rsa.pub 文件添加到GitHub和coding的SSH公钥里面，建议coding有效期选永久。</p><h2 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h2><p>执行下面的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure></p><p>它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。<br>直接回车就行。<br>然后去C:\Users\Administrator.ssh目录 找到id_rsa.pub 文件就是生成好的公钥，添加到GitHub和coding。<br>公钥的大概样子，全部复制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU</span><br><span class="line">GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3</span><br><span class="line">Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA</span><br><span class="line">t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En</span><br><span class="line">mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx</span><br><span class="line">NrRFi9wrf+M7Q== schacon@agadorlaptop.local</span><br></pre></td></tr></table></figure></p><h2 id="测试公钥是否添加成功"><a href="#测试公钥是否添加成功" class="headerlink" title="测试公钥是否添加成功"></a>测试公钥是否添加成功</h2><p>测试GitHub。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Git%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5/QQ%E5%9B%BE%E7%89%8720180505165306.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>现在就添加成功了。</p><p>测试Coding<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://hexo-1252491761.file.myqcloud.com/Git%E7%94%9F%E6%88%90SSH%E5%85%AC%E9%92%A5/QQ%E5%9B%BE%E7%89%8720180505170650.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E7%94%9F%E6%88%90-SSH-%E5%85%AC%E9%92%A5</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git生成SSH公钥&quot;&gt;&lt;a href=&quot;#Git生成SSH公钥&quot; class=&quot;headerlink&quot; title=&quot;Git生成SSH公钥&quot;&gt;&lt;/a&gt;Git生成SSH公钥&lt;/h1&gt;&lt;p&gt;大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://blog.langpz.com/tags/Git/"/>
    
      <category term="SSH公钥" scheme="http://blog.langpz.com/tags/SSH%E5%85%AC%E9%92%A5/"/>
    
  </entry>
  
</feed>
